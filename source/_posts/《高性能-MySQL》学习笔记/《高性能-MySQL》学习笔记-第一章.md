---
title: 《高性能 MySQL》学习笔记 第一章
date: 2020-01-30 20:36:55
tags: 《高性能 MySQL》学习笔记
---
# MySQL 的架构

最上层 服务器层

第二层 查询执行引擎
大多数 MySQL 的核心服务功能位于这一层，比如：查询解析、分析、优化、缓存以及所有的内置函数。所有跨存储引擎的功能也都位于这一层，比如：存储过程、触发器、视图等。

第三层 存储引擎
存储引擎负责 MySQL 中数据的存储与提取。第二层通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使这些差异对上层的查询过程透明。
存储引擎不会解析 SQL 语句。InnoDB 是个例外，它会解析外键，因为 MySQL 服务器中没有实现解析外键这一功能。
存储引擎之间不会相互通信，只是简单的响应上层的请求。

<!--more-->

# 连接管理与安全

1. One-Connection-Per-Thread 方式

   > 参考 [MySQL Connection Handling and Scaling](https://mysqlserverteam.com/mysql-connection-handling-and-scaling/)

   MySQL Sever 作为一个进程在系统中存在。

   对于每一个客户端连接，MySQL 都会在服务器进程中创建一个线程。

   MySQL 没有自己的线程实现。线程依赖于MySQL 所在的操作系统。

   MySQL 使用 thread-cache 将不用的线程缓存起来，避免线程的频繁创建和释放。

   客户端发起连接时，先在线程缓冲池中寻找闲置的线程并使用它，若未找到，则创建一个新线程。

   下图展示客户端连接到 MySQL 服务器的过程

   ![Connect-768x320.png](http://ww1.sinaimg.cn/large/006XJF4Oly1gbq9st6g8fj30lc08wdgx.jpg)

   客户端发起的连接请求放入请求队列中。

   Receiver Thread 用于为用户请求创建用户线程。

   Receiver Thread 首先在线程缓存中查找空闲的线程并使用它，若未找到，则创建一个新线程。线程缓存的大小=8+(最大连接数÷100)。

   用户线程用于处理客户端与服务器的一切交互。例如，回复握手的相应报文。用户线程分配并初始化自己的 THD，然后继续进行能力协商和身份验证。一切都完成后，由连接阶段进入命令阶段。

   THD，一个用于描述客户端与服务器连接的数据结构，用于跟踪用户查询执行状态的方方面面。THD 随着连接建立而创建，在连接终止时销毁。每一个用户连接都对应一个 THD。THD 与线程不同，不会被重用。THD 定义在 `sql_calss.h` 中。THD 占用的内存会随着查询的执行而显著增长。

   下图展示命令阶段，客户端与服务器的交互

   ![QueryResult-768x147.png](http://ww1.sinaimg.cn/large/006XJF4Oly1gbq9t32gpnj30lc04374j.jpg)

   下图展示连接的释放过程

   ![Disconnect-768x176.png](http://ww1.sinaimg.cn/large/006XJF4Oly1gbq9tbr76cj30lc04wgm2.jpg)

   连接关闭时，该连接使用的线程会被清理。若线程缓冲中有空位，则将该线程挂起到线程缓冲中，否则将该线程销毁。

2. Thread-Pool

   > 参考 [MySQL 线程池总结](https://www.cnblogs.com/cchust/p/4510039.html)

   One-Connection-Per-Thread 方式下，连接数的暴增会导致需要创建同样多个数的用户线程，高并发线程导致高内存消耗和更多的线程切换，降低 cache 命中率。

   Thread-Pool 实现方式中，线程处理的最小单位是查询语句，一个线程可以处理多个连接的请求。 

# 优化与执行

MySQL 会解析查询，并创建解析树，然后对其进行优化。

用户可以通过特殊的关键字提示优化器，影响它的决策进程。也可以请求优化器解释优化的过程。

优化器不关新表使用的存储引擎，但会向存储引擎请求一些用于优化的信息。

SELECT 语句在查询解析前，服务器会先检查查询缓存，若缓存命中，则直接返回查询结果，不再进行查询解析和优化。

# 并发控制

读锁是共享的，写锁是排他的。

# 锁粒度

一种高并发的思路是让锁定对象更有选择性。尽量只锁定需要修改的部分数据。

在给定的资源上，锁定的数据量越少，系统的并发程度越高。

表锁是 MySQL 中最基本的锁策略，并且开销最小。

表锁在 MySQL 服务层实现了。

写锁比读锁有更高的优先级，写锁请求可能会被插入到读锁请求之前。

行级锁，可以最大程度的支持并发，同时也带来了最大的锁开销。

行级锁只在存储引擎层实现，而 MySQL 层没有实现。

所有的存储引擎都以自己的方式实现了锁机制。

# 事务

事务是一组原子性的 SQL 查询。

原子性 Atomicity

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部成功提交，要么全部失败回滚。不可能只执行其中的一部分操作。

一致性 Consistency

数据库总是从一个一致性的状态转换到另一个一致性的状态。

隔离性 Isolation

通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的。有四个隔离级别。

持久性 Durability

一旦事务提交，其所做的修改就会永久的保存到数据库中。持久性也有很多级别。备份可以增加持久性。

# 事务的四种隔离级别

1. Read Uncommitted
事务中的修改对其他事务可见。事务可读取未提交的数据，导致脏读。性能上不比其他隔离级别好太多。一般不使用。
脏读是指，事务读取了未提交的数据。
2. Read Commit
大多数数据库系统的默认隔离级别。MySQL 不是。满足隔离性的定义。事务提交之前对其他事务不可见。也称为不可重复读 Nonrepeatable Read。
不可重复读是指，执行两次同样的查询，可能会得到不同的结果。
4. Repeatable Read
无脏读问题。保证在同一个事务中，多次读取同样记录的结果是一致的。存在幻读问题。
幻读是指，一个事务 A 在读取某一范围内的数据后，另一事务 B 在该范围内插入了新数据，事务 A 再次读取该范围内的数据时，会产生幻行。InnoDB 和 XtraDB 通过多版本并发控制解决了幻读问题。
可重复读是 MySQL 的默认事务隔离级别。
5. Serializable 可串行化
最高的隔离级别。强制事务串行处理。会在读取每一行数据时都加上锁，可能导致大量超时和锁争用问题。很少使用该级别。
| 隔离级别         | 是否会脏读 | 是否会不可重复读 | 是否会幻读 | 读时是否加锁 |
| ---------------- | ---------- | ---------------- | ---------- | ------------ |
| Read Uncommitted | 是         | 是               | 是         | 否           |
| Read Commit      | 否         | 是               | 是         | 否           |
| Repeatable Read  | 否         | 否               | 是         | 否           |
| Serializable     | 否         | 否               | 否         | 是           |
> SQL 关键字不区分大小写

# 死锁

* 死锁是指，两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

* InnoDB 目前处理死锁的方法是，将持有最少行级排他锁的事务回滚。
* 锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有的存储引擎会产生死锁，有的则不会。死锁产生有双重原因：真正的数据冲突和存储引擎的实现方式。
* 死锁产生后，只有部分或者完全回滚一个事务才能打破死锁。

# 事务日志

* 存储引擎在修改数据时，只需要修改内存拷贝，再把修改行为记录到持久在硬盘上的事务日志中，不用每次都将修改的数据持久到磁盘。
* 事务日志采取追加的方式，写日志操作是在磁盘上一小块区域内的顺序 I/O。
* 日志持久后，内存中被修改的数据可以在后台慢慢的刷回硬盘。这种方式被称为预写式日志，修改数据需要两次写磁盘。

# 两阶段锁协议

* 在事务执行的过程中，随时都可以加锁。锁只有在执行 COMMIT 或者 ROLLBACK 时才会释放，并且所有的锁在同一时刻释放。InnoDB 会根据隔离级别在需要的时候自动加锁。
* 两阶段锁协议是为了保证事务的隔离性。 

# MVCC 多版本并发控制

* 可以视为行级锁的一个变种，在很多情况下避免了加锁操作。

* MVCC 没有统一的实现标准。但基本都实现了非阻塞的读操作，写操作也只锁定必要的行。

* MVCC 通过保存数据在某个时间节点的快照来实现。

* 不管执行多长时间，每个事务看到的数据都是一致的。

* 根据事务的开始时间不同，每个事务在同一时刻，对同一张表看到的数据可能不同。

* MVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下起作用。

* MVCC 与 READ UNCOMMITTED 和 SERIALIZABLE 隔离级别下不兼容。因为 READ UNCOMMITTED 总是读到最新的数据。SERIALIZABLE 会对所有读操作加锁。

* InnoDB 的 MVCC 实现

  * InnoDB 通过在每条行记录后面保存两个隐藏的列来实现 MVCC。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间）。时间不是真正的时间，而是指系统版本号。每开始一个新的事务，系统版本号就会自增一。事务开始时刻的系统版本号作为事物的版本号。

  * SELECT READ COMMITTED 隔离级别

    InnoDB 根据以下两个条件检查每行记录

    * 创建版本早于等于当前事务版本的数据行。确保事务读取的行在事务开始前已经存在，或者是由事务本身插入或修改过的。
    * 删除版本未定义或者大于当前事务版本的数据行。确保事务读取到的行，在事务开始之前未被删除。

  * INSERT READ COMMITTED 隔离级别

    为每个新插入的行保存当前事务的版本号作为行的创建版本号。

  * DELETE READ COMMITTED 隔离级别

    为删除的行保存当前事务版本号作为行的删除版本号。

  * UPDATA READ COMMITTED 隔离级别

    InnoDB 会插入一行新纪录，并将该新行的创建版本号设置为当前事务的版本号。同时将原先旧行的删除版本号设置为当前事务的版本号。

# 裸设备

也称为裸分区。是一种没有经过格式化，不被操作系统管理的特殊块设备。裸设备由应用程序负责对它进行读写操作。裸设备不被操作系统管理，少了操作系统这一层，因而 I/O 效率更高。不少数据库都能通过使用裸设备作为存储介质来提高 I/O 效率。
# InnoDB 数据引擎

MySQL 的默认存储引擎。该存储引擎主要用于处理大量的短期事务，短期事务大部分情况下是正常提交的，很少会被回滚。

## 表空间

InnoDB 的数据存储在表空间中，表空间是由 InnoDB 管理的黑盒子，由一系列的文件组成。

共享表空间：整个数据库的所有数据存储在一个单独的表空间中。

优点：表空间可以自动分成多个文件存放到不同的磁盘上，一个表的数据可以分布在不同的文件上。表大小不受文件系统的限制，而只受 InnoDB 自身限制。由 InnoDB 的官方文档可知，其表空间的上限为 64TB。

缺点：所有的数据和索引放在同一个文件中，当数据量非常大时，表做了大量删除操作后，表空间中会有大量的空隙。共享表空间分配后不能回收。当创建临时索引或者临时表导致共享表空间扩大后，就算删除相关的表也没办法回收那部分空间。

独立表空间：每个表都有自己独立的表空间，每个独立表空间都对应磁盘上的一个物理文件。

优点：数据存储清晰，灾难恢复相对容易，不会影响其他表。可以实现单表在不同的数据库中移动。空间更容易回收。此时，表的大小限制取决于文件系统对单个文件的大小限制。

## MVCC 

InnoDB 使用 MVCC 支持高并发，并且实现了四个隔离级别，默认隔离级别为 REPEATABLE READ。

## 间隙锁

InnoDB 在 REPEATABLE READ 隔离级别下，通过间隙锁策略防止防止幻读的出现。

间隙锁使得 InnoDB 不仅仅锁定查询涉及行，还会锁定索引中的间隙，以防止幻影行的插入。

## 聚簇索引

聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。其特点是存储数据的顺序和索引顺序一致。

## 可预测性预读

预读是 InnoDB 优化 I/O 的一种方式。预读请求是一个 I/O 请求。以异步方式预取缓冲池中的多个页面，同时预计很快会用到这些页面。

数据库求数据的时候，会将请求交给文件系统，放入文件系统的请求队列中。相关进程从请求队列中取出读请求，根据需求到相关数据区读取数据。取出的数据放入响应队列中，数据库从响应队列中将数据取走，完成一次数据读的操作过程。

InnoDB 有两种预读算法：线性预读和随机预读。

## 自适应哈希索引

InnoDB 存储引擎会监控表上二级索引的使用情况。如果发现某二级索引被频繁访问，则会建立哈希索引来加快访问速度。

只适用于等值查询，不适应与范围查询。

## 插入缓冲机制

能够加快插入操作。对删除、更新操作同样有效。

对于非聚集索引的插入或更新操作，不是每一次操作都直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中。如果在，则直接插入。如果不在，则先将数据放入插入缓冲区，返回插入成功的结果。然后由 master thread 以一定的频率执行插入缓冲和非聚集索引叶子节点的合并操作。这时，通常能够将多个插入合并到一个 I/O 操作中。

[InnoDB 事务模型和锁](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html)

## 真正的热备份

> 冷备份：冷备份发生在数据库已经正常关闭的情况下。离线复制一份数据，有需要时直接用这个备份恢复
>
> 热备份：在数据库持续运行的情况下进行备份。

InnoDB 通过一些机制和工具支持真正的热备份。

# MyISAM 存储引擎

MySQL 5.1 之前的默认存储引擎。不支持事务和行级锁。崩溃后无法安全恢复。对于只读数据，或者表比较小，可以忍受修复操作的应用，可以依旧使用该引擎。MyISAM 只将数据写入内存中，然后等待操作系统定期将数据刷出到磁盘上。

## 存储

表存储在两个文件中：数据文件和索引文件，分别以 .MYD 和 .MYI 为扩展名。

MyISAM 表可以包含静态行和动态行。

MyISAM 指向记录的指针限制了记录的最大长度。MySQL 5.0 中该指针的大小为 6B，内存按照字节编址，所以记录的最大长度为 256TB。该指针可以通过修改表的 MAX_ROWS 和 AVG_ROW_LENGTH 来修改。

## 加锁与并发

MyISAM 对整张表加锁，而不是行锁。读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。表在读取查询的同时，也可以向表中插入新的记录，称为并发插入。

## 修复

对于 MyISAM 表，MySQL 可以执行修复操作。修复与事务恢复和崩溃恢复是不同的。执行表的修复可能会导致一些数据丢失，并且修复操作是非常缓慢的。MySQL 服务器关闭的情况下，可以通过 myisamchk 命令行工具进行检查和修复。

## 索引特性

对于 MyISAM 表，可以基于长字段的前 500 个字符建立索引。支持全文搜索。

## 延迟更新索引键

延迟更新索引键功能可以在全局打开，也可以针对单个表打开。

创建 MyISAM 表时，指定 DELAY_KEY_WRITE 选项，打开延迟更新索引键功能。

延迟更新索引键开启后，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是写入内存的键缓冲区中，只有在清理键缓冲区或者关闭表时才会将对应的索引块写入磁盘。

减少磁盘 I/O 次数，极大提升写入性能。

但是，在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

## 压缩表

表在创建并导入数据后，不会再进行修改操作，这样的表适合采用 MyISAM 压缩表。

压缩表不能修改，除非将表解除压缩。

压缩表可以极大的减少磁盘空间占用，因此减少磁盘 I/O。

# CSV 引擎

CSV 引擎可以将普通的 csv 文件作为 MySQL 的表来处理，但这种表不支持索引。

将 csv 文件放在 MySQL 的数据目录下，就能在 MySQL 中打开。

将数据写入一个 CSV 引擎表，其他程序也能立即从表的数据文件中读取 CSV 格式的数据。

CSV 引擎可以作为一种数据交换机制。

# Memory 引擎

需要快速访问数据，这些数据不会修改，重启后丢失也没关系。此时可以使用 Memory 表。

Memory 表保存在内存中，访问速度快。

Memory 表的结构在重启以后会保留，但数据会丢失。

支持 Hash 索引，访问非常快。

Memory 表是表级锁，因此并发写入能力较低。

行的长度是固定的。指定的 VARCHAR 列会被转换为 CHAR。不支持 BLOB 或 TEXT 类型的列。

如果 MySQL 在执行查询过程中需要使用临时表保存中间结果，内部使用的临时表就是 Memory 表。如果中间结果太大超出了 Memory 表的限制，或者临时表含有 BLOB 或者 TEXT 字段，那么临时表就会转换为 MyISAM 表。

# OLTP 类引擎

OLTP 联机事务处理 On-Line Transaction Processing，表示事务性非常高的系统。一般都是高可用的在线系统，以小的事务和小的查询为主。其性能评估一般看每秒执行的事务和 SQL 语句的数量。典型的 OLTP 系统有电子商务系统、银行、证券等。

TokuDB 引擎，使用分型树作为索引数据结构。

# 面向列的存储引擎

MySQL 默认是面向行的，每一行的数据是一起存储的，服务器的查询也是以行为单位处理的。

有时，在处理大批量的数据时，不需要整行的数据，面向列的方式可以传输更少的数据。

如果每一列都单独存储，压缩效率会更高。

OLAP 联机分析处理 On-Line  Analytical Processing，也叫做联机分析处理系统，有时也叫 DDS 决策支持系统。

# 转换表的引擎

将表的存储引擎转换为另一种存储引擎。

转换表的存储引擎，会失去和原引擎相关的所有特性。

Percona ToolKit 提供了 pt-online-shema-change 工具，可以用来转换表的存储引擎。

## ALTER TABLE 语句

```SQL
ALTER TABLE mytable ENGINE = InnoDB;
```

特点：耗时长。MySQL 会将原表加读锁，然后将原表复制到一张新表中。

## 导入与导出

使用 mysqldump 工具将数据导出到文件，然后修改文件中 `CREATE TABLE` 语句的存储引擎选项，同时修改表名。

同一个数据库中，不能存在同名的表，即使两个表使用了不同的存储引擎。

mysqldump 默认会自动在 `CREATE TABLE` 语句前加上 `DROP TABLE` 语句。

## 创建与查询

先创建一个新的存储引擎的表，然后利用 `INSERT ... SELECT` 语句导出数据。

```SQL
CREATE TABLE innodb_table LIKE myisam_table;
ALTER TABLE innodb_table ENGINE=InnoDB;
INSERT INTO innodb_table SELECT * FROM myisam_table;
```

数据量不大时，效果很好。

数据量大，可以分批处理。比如利用主键字段 id 和最大值 y 与 最小值 x，进行分批插入。

```SQL
START TRANSACTION;
INSERT INTO innodb_table SELECT * FROM mysiam_table
WHERE id BETWEEN x AND y;
COMMIT;
```

