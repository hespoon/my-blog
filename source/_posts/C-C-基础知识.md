---
title: C++/C 基础知识
date: 2020-02-26 17:15:23
tags:
---
# const 关键字
* const 修饰普通变量
```C++
const int a = 7;
```
a 为常量，只能在声明时赋值，不可再次赋值。指向常量的指针和引用，必须被 const 修饰，这样用于防止通过指针或引用修改该常量。

* 指向常量的指针
```C++
const int *p = 8;
int const *p = 8;
```
const 位于 * 的左边，不能通过指针修改指针指向的值。指向常量的指针，可以指向常量也可以指向普通类型。关键是不能通过指针修改指针指向的值。

* 常指针
```C++
int * const p = 8;
```
const 位于 * 的右边，指针是一个指针常量，指针指向的内存地址不能改变，但可以通过指针修改指针指向的值。

* 指向常量的常指针
```C++
int const * const p = 8;
```
const 在 * 的两边都有，指针指向的内存地址不能改变，地址中的值不能通过指针改变。
常指针和指针常量的合并。

* const 修饰函数参数
```C++
// 传值参数
void f(const int a){
    a++; // 错误，不能在函数中修改 a 的值
}
void f(int const *a){
    *a=10; // 错误，不能通过指针修改 a 的值
}
void f(int * const a){
    *a=10; // 正确
    int b=10;
    a=&b; // 错误，不可以改变指针指向的内存地址
}
```
当函数参数是一个自定义的对象时，按值传参时会构建临时对象复制参数，一般采用传引用，为了防止参数在函数体内被修改，常用 const 修饰参数。

* const 修饰函数返回值
 1. const 修饰基本数据类型，修饰与不修饰作用相同。
 2. const 修饰自定义类型。此时返回一个常量，返回值不能做左值。返回值既不能被赋值，也不能被修改。
 3. const 修饰返回的指针或引用。

* const 修饰类的成员函数 
const 加在 () 后面
const 修饰成员函数，是为了防止成员函数修改调用这个函数的对象的值。一个类中，任何不会修改数据成员的函数都应该声明为 const 类型。const 修饰的成员函数称为常成员函数，常成员函数不能调用非常成员函数，用来防止常成员函数修改类的属性。只有常成员函数能够操作常对象，没有 const 修饰的的成员函数不能用来操作常对象。如果对象的某个属性希望被自己的 const 成员函数修改，则可以用 mutable 修饰该属性。

* const 修饰引用
const 引用是指向 const 对象的引用。同时，普通的引用是无法绑定到 const 对象上的。为了防止通过普通的引用修改 const 对象。

# static 关键字

* 静态成员变量
类内成员变量声明前加上关键字 static，该数据成员就是类内的静态数据成员。

* 静态成员变量的特点
1. 静态成员变量是该类所有对象共有的。静态成员变量只分配一次内存，由该类的所有对象共享访问。
2. 静态数据成员在全局数据区分配内存，不属于特定的对象，不占用对象的内存。在没有类的实例存在前，静态成员变量就已经存在了。
3. 静态成员变量在初始化时分配内存。静态变量必须初始化，并且只能在类体外进行。初始化时可以赋初值，也可以不赋初值。如果不赋初值，则会被默认初始化。静态数据区的变量都有默认的初始值，动态数据区的变量默认是垃圾值。
4. static 成员变量与普通 static 变量相同，编译时在静态数据区分配内存，到程序结束时才释放。
5. 静态数据成员初始化时可以不加 static，但必须要有数据类型。
6. 静态数据成员可以通过 <类名>::<静态数据成员名> 访问，不需要通过类的对象。
7. sizeof 运算不会计算静态成员变量的大小。

* 静态成员函数
静态成员函数是为某一个类服务的。静态成员函数不作用于某个具体的对象。普通成员函数隐含了一个 this 指针，该 this 指针指向类的对象本身。函数调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this 是缺省的。
静态成员函数属于类本身，不作用与具体的对象，因此它不具有 this 指针。静态成员函数不能访问非静态成员变量和非静态成员函数，只能访问其余的静态成员变量和函数。

* 静态成员函数的特点
1. 出现在类体外的函数定义不能指定关键字 static
2. 静态成员函数仅可以访问静态成员变量和静态成员函数
3. 静态成员函数不能访问非静态成员函数和非静态成员变量
4. 非静态成员函数可以任意的访问静态成员函数和静态成员变量

* 拷贝构造函数的问题
使用包含静态成员的类时，有时会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时类对象消亡时会调用析构函数，析构函数中可能会修改静态成员变量，但是这些临时对象在创建时却没有执行构造函数中的对静态成员变量修改的操作。此时应当在类中写一个拷贝构造函数，让临时对象的创建使用该拷贝构造函数，在拷贝构造函数中规范拷贝对象时的操作。

* 静态全局变量
在全局变量之前加上 static 关键字。

* 静态全局变量的特点
1. 该变量在全局数据区分配内存
2. 未经初始化的静态全局变量有一个默认的初始化值。与之相比，普通变量的默认初始化值是垃圾值。
3. 静态全局变量在声明它的整个文件内都是可见的，在文件外不可见。
4. 对于一个完整的程序，在内存中的分布情况如下：【代码区】、【全局数据区】、【堆区】和【栈区】。一般由 new 产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据，包括函数内部的静态局部数据，存放在全局变量区。
5. 静态全局变量不能被其他文件使用。在其他文件中，可以定义相同名字的变量，不会产生冲突。

* 静态局部变量
在局部变量之前加上 static 关键字，该变量就被定义为一个静态局部变量。
函数中的普通局部变量存放在栈中，函数退出时系统会回收栈的内存，局部变量也就失效了。
有时，我们希望在两次调用之间对局部变量的值进行保存，此时就可以使用静态局部变量。
静态局部变量只在第一次函数调用时初始化一次。且存放在全局数据区，每次调用的值保持到下一次调用。
静态局部变量始终驻留在函数的全局数据区中，直到程序运行结束。但其作用域为局部作用域，当定义它的语句块结束时，其作用域随之结束。

* 静态函数
在函数的返回类型前加上 static 关键字，函数被定义为静态函数。静态函数只在声明它的文件中可见，不能被其他文件使用。其他文件中可以定义同名函数，不会发生冲突。

# 虚函数与纯虚函数

* 虚函数是实现多态的机制。多态性使得程序调用的函数是在运行时动态决定的，而不是编译时静态决定的。其核心理念是通过基类访问派生类实现的函数。使用一个基类类型的指针或引用指向子类对象，进而调用由子类复写的个性化的虚函数。

* 虚函数，在类的成员方法的声明前加 virtual 关键字。
```C++
virtual void f();
```

* 纯虚函数，在虚函数的声明后加 “= 0”
```C++ 
virtual void f() = 0;
```

* 虚函数表
每一个包含虚函数的类都包含一个虚函数表
虚表是一个指针数组，指针是指向虚函数的函数指针。
虚表是属于类的，而不是属于某个对象，一个类只需要一个虚表即可。同一个类的所有对象公用一个虚表。
为了指定对象的虚表，对象内部包含一个指向虚表的指针。类对象在创建时便拥有了指向虚表的指针，指针会自动指向对象所属类的虚表。
对象的虚表指针指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数。

* 对于虚函数，子类可以重写虚函数，也可以不重写。对于纯虚函数，子类必须重写。
* 当使用类指针调用成员函数时，普通函数由指针类型确定，虚函数由指针指向的实际类型确定。
* 含有纯虚函数的类称为抽象类，它不能生成对象。
* 当基类中的某个成员方法，在大多数情况下都应该由子类提供个性化实现，但基类中也可以提供缺省的备选方案时，该方法设计为虚函数。当基类的某个成员方法，必须由子类提供个性化实现时，应该设计为纯虚函数。
* 构造函数不能是虚函数，析构函数可以是虚函数且推荐设置为虚函数。基类的析构函数是虚函数，可以确保，在使用基类指针销毁派生类对象时，派生类的析构函数能够被调用，因为派生类的虚构函数一般会有释放一些派生类对象独有的内存这样的操作。

# 函数指针

函数存放在内存的代码区域，同样具有地址。
函数指针指向的函数一定要保持函数的返回值类型，函数参数个数、类型和函数指针一致。
函数指针可以作为参数传递给函数
还可以构成函数指针数组
类成员函数指针和普通函数指针是不同的。
类成员函数指针要通过 `.*` 或者 `->*` 运算符使用。
类成员函数指针指向类中的非静态成员函数时，必须由类的实例对象调用，用于传递给函数 this 指针。
指向类的静态成员函数的函数指针在声明时可以不加类名。调用时可以不使用类的实例对象。
普通成员的函数指针可以通过 `*` 运算符使用。

# 内联函数

内联函数是为了解决程序中函数调用的效率问题。如果函数为内联函数，则在程序编译时，编译器会将程序中出现的内联函数表达式用内联函数体进行替换。是一种空间换时间的操作。内联函数一般都比较小。
内联函数中最好不要使用循环语句，内联函数的定义必须出现在内联函数第一次调用之前，类内部定义的函数是内联函数。

# 函数签名

C++ 的函数签名包含函数名和函数的参数列表，不包含返回类型。函数签名用于识别不同的函数。

# 构造函数

构造函数不需要用户调用，而是在建立对象时自动执行。函数名称与类名相同，没有返回值。
声明类数组时，数组中的每一个元素都会调用一次构造函数。假设数组长度为 n，则会调用 n 次构造函数。
声明类的指针数组时，不会调用类的构造函数。

```C++
class cls {
public:
	static int executeCount;
	cls() {
		executeCount++;
		cout << executeCount << "  "; // 输出当前是第几次调用构造函数
	}
};
int cls::executeCount = 0; // 静态成员变量初始化
int main() {
	cls a[5]; // 会调用 5 次默认构造函数
    cls * b[8]; // 不会调用构造函数
	return 0;
}
```

1. 无参数的构造函数
2. 带参数的构造函数，属于构造函数的重载。构造函数的参数可以有默认初值。

# 拷贝构造函数

用于对象复制。函数名与类名一致，参数一般是一个本类型对象的引用。

* 拷贝构造函数调用时机
1. 对象以传值的方式传入函数参数时。
2. 对象以传值的方式从函数返回时。
3. 使用另一个同类型的对象来初始化新创建的对象时。

* 深拷贝与浅拷贝
默认的拷贝构造函数没有处理类的静态数据成员。
浅拷贝是指，在对象复制时，只对对象中的数据成员进行简单的赋值，不会正确处理指针，指针只是简单的指向相同的内存空间。此时，拷贝出来的对象会影响原来的对象。
深拷贝时，对象中的成员变量，不再是简单的赋值，而是重新分配内存空间。

# 指针与引用的区别

* 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。引用跟原来的变量是同一东西，只不过是原变量的一个别名而已。
* 有 const 指针，没有 const 引用
* 指针可以有多级，引用只能由一级
* 指针可以为空，引用不能为空

# 回车与换行 \r \n
| 符号  | ASCII码 | 意义  |
| :---: | :-----: | :---: |
|  \n   |   10    | 换行  |
|  \r   |   13    | 回车  |

在 windows 中：
`\r` 回车，表示回到当前行的行首，而不会换到下一行。如果接着输出，本行的内容会被覆盖
`\n` 换行，换到当前位置的下一行，而不会回到行首。
按下键盘回车键相当于输入 `\r\n`

在 Unix 系统中：
`\n` 会换到下一行的行首。
按下回车键相当于输入 `\n`

在 Mac 中：
`\r` 会换到下一行的行首。
按下回车键相当于输入 `\r`

一般在程序中写 `\n` 在 Linux\windows 中都能实现换到下一行的行首的功能。只是在文本文件中，Linux 只有 `\n`，Windows 中是 `\r\n`。

# 标准输入输出

* scanf 和 printf
头文件：
<cstdio>
输入格式：


