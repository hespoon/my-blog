---
title: KMP 算法
date: 2019-12-19 22:05:25
tags:
---
* 后缀子串：字符串 s 的后缀子串，是指最后一个字符与 s 对齐的子串，不包括 s 本身。比如 abc 的后缀子串包括 c，bc，不包括 abc 本身。
* 前缀子串：字符串 s 的前缀子串，是指起始字符跟 s 对齐的子串，不包含 s 本身。比如 abc 的前缀子串包括 a，ab，不包括 abc 本身。
* 最长相等前后缀：字符串 s 的最长相等前后缀是指，s 的相等的前缀子串和后缀子串中长度最长的那一个。
* 最长可匹配后缀子串（最长可匹配后缀）：最长相等前后缀对应的那个后缀子串。
* 最长可匹配前缀子串（最长可匹配前缀）：最长相等前后缀对应的那个前缀子串。
> 以字符串 ababa 为例
  其前缀子串为：a、ab、aba、abab
  其后缀子串为：a、ba、aba、baba
  最长相等前后缀为 aba ，长度为 3。
  最长可匹配前缀子串为 aba。
  最长可匹配后缀子串为 aba。
  明显最长可匹配前缀子串和最长可匹配后缀子串两者是相同的，前者是前缀，后者是后缀。
  字符串 s 的最长相等前后缀即，字符串 s 的后缀子串中，与 s 的某个前缀子串相同且长度最长的那个。同理，s 的最长相等前后缀也即，字符串 s 的前缀子串中，与 s 的某个后缀子串相同且长度最长的那个。
1. KMP 算法中，模式串从左向右与文本串进行匹配。类比于 BM 算法的说法，模式串从前向后与文本串进行匹配。
2. KMP 算法就是在试图寻找一种规律：在模式串和主串的匹配过程中，当遇到不匹配的字符后，如何利用模式串中已经与文本串匹配的那部分字符串（即模式串中位于不匹配字符的左边的字符串），将模式串一次性滑动很多位？
3. 坏字符：在模式串与文本串匹配的过程中，把不能匹配的那个字符称为坏字符，坏字符是文本串中的字符。
好前缀：在模式串与文本串匹配的过程中，将失配字符左边的模式串中已经匹配的那段字符串称为好前缀。
4. 当模式串与文本串失配时，假设坏字符对应的模式串字符在模式串中的下标为 j。在好前缀中，查找好前缀的最长相等前后缀，设为{v}，长度为 k，此时将模式串向后滑动 j-k 位。
即 j=j-(j-k) → j=k，将 j 更新为 k 
5. 如何求解好前缀的最长相等前后缀？我们发现这个问题不涉及文本串，只与模式串有关，因为好前缀一定是模式串的前缀。因此可以事先预处理模式串，在模式串与文本串的匹配过程中，直接使用预处理的结果。通过5可知，我们希望得到好前缀的最长相等前后缀。并且，模式串的每个前缀都可能是好前缀。当模式串本身就是好前缀时，表示模式串与文本串匹配成功。因此，我们希望通过预处理得到模式串的每个前缀的最长相等前后缀的长度，设为 len（对应 7 中的定义一）。或者得到模式串的每个前缀子串的最长可匹配前缀子串的结尾字符的下标，设为 index（对应 7 中的定义二）。明显，len=index+1。
6. 定义 next 数组。设模式串为 m。
next 数组定义一：next 数组的下标 i 表示模式串的前缀 m[0,i]。下标对应的数组值 next[i] 表示前缀 m[0,i] 的最长可匹配前后缀的长度。
> 以 m=ababacd 为例。
  next[0]=0;
  next[1]=0;
  next[2]=1;
  next[3]=2;
  next[4]=3;
  next[5]=0;
  next 数组定义二：next 数组的下标 i 表示模式串的前缀 m[0,i]。下标对应的数组值 next[i]   表示前缀 m[0,i] 的最长可匹配前缀的结尾字符的下标。
  以 m=ababacd 为例。
  next[0]=-1;
  next[1]=-1;
  next[2]=0;
  next[3]=1;
  next[4]=2;
  next[5]=-1;
  明显，正如 5 中所说，定义一的 next 数组的值比定义二的 next 数组中对应的值大一。并且，next[5] 是没有用的，因为这时文本串与模式串已经完全匹配。
7. 求解 next 数组
由于定义一的 next 数组与定义二的 next 数组没有本质区别，下文只求解定义二的 next 数组
首先，next 数组的长度与模式串的长度相同。计算时按照下标从小到大依次计算 next 数组的值。利用动态规划的思想，当计算 next[i] 时，要利用前面计算出的 next[0]，next[1]，... next[i-1]。next[0]=-1 是明显成立的。计算 next 数组时下标从 1 开始。
计算 next[i] 时分为两种情况。假设 next[i-1]=k，即子串 m[0,i-1] 的最长可匹配前缀为 m[0,k]
    1. 如果 m[i]==m[k+1]，说明子串 m[0,i] 的最长可匹配前缀为 m[0,k+1]。此时，令 next[i]=k+1 即可。
    2. 如果 m[i]!=m[k+1]，说明子串 m[0,i] 的最长可匹配前缀不是 m[0,k+1]。此时，应寻找前缀 m[0,i-1] 的次长可匹配前缀，即令 k=next[k]，直到 k=-1 或 m[i]=m[k+1] 为止。
        2.1. 若 k=-1，则令 next[i]=-1
        2.2. 若 m[i]=m[k+1]，则令 next[i]=k+1
8. 上述计算 next 数组的过程中，最令人费解的步骤莫过于 `k=next[k]`。下面重点解释该步骤的原理，最好自己画个图。
触发该步骤的条件为 m[i]!=m[k+1]，表示 m[0,i-1] 的最长可匹配前缀子串的下一个字符不等于 m[i]。现在，我们考察 m[0,i-1] 的次长可匹配前缀子串 m[0,x]（x 为未知量） 的下一个字符是否等于 m[i]。如果等于，则 m[0,x+1] 就是 m[0,i] 的最长可匹配后缀子串。
问题转换为如何求得 m[0,i-1] 的次长可匹配前缀子串。现已知 m[0,i-1] 的最长可匹配前缀子串为 m[0,k]，而次长可匹配前缀子串一定包含在最长可匹配前缀子串中。所以 m[0,i-1] 的次长可匹配前缀子串就是前缀 m[0,k] 的最长可匹配前缀子串！而 m[0,k] 的最长可匹配前缀子串是 m[0,next[k]]，即令 k=next[k]!
9. KMP 算法结束，代码如下
```C++
/*
求解定义二的 Next 数组
*/
// 简化版
void getNext(int *Next, string P)
{
  Next[0] = -1;                        // 明显恒成立
  for (int i = 1; i < P.length(); i++) // 求解 Next[1]~Next[P.length-1]
  {
    int k = Next[i - 1];  // P[0,k] 是 P[0,i-1] 的最长可匹配前缀
    if (P[k + 1] == P[i]) // P[k+1]=P[i]，这种情况下最简单，说明 P[0,i] 的最长可匹配前缀为 P[0,k+1]
    {
      Next[i] = k + 1;
    }
    else // P[k+1]!=P[i]，说明 P[0,i] 的最长可匹配前缀不是 P[0,k+1]，此时寻找 P[0,i-1] 的次长可匹配前缀
    {
      while (k != -1 && P[i] != P[k + 1])
      {
        k = Next[k]; // 不断寻找 P[0,i-1] 的次长可匹配前缀
      }
      if (P[i] == P[k + 1])
      {
        Next[i] = k + 1;
      }
      else if (k == -1)
      {
        Next[i] = -1;
      }
    }
  }
}
// 精华版
void getNext2_2(int *Next, string P)
{
  int j = -1;
  Next[0] = -1; // 初始化 Next 数组
  for (int i = 1; i < P.length(); i++)
  { // 求解 Next[1]~Next[P.length()-1]
    while (j != -1 && P[i] != P[j + 1])
    {              // 试图用 P[j+1] 匹配 P[i]
      j = Next[j]; // 不断后退，直到 j==-1 或 P[i]==P[j+1]
    }
    if (P[i] == P[j + 1])
    {
      j++; // 先令 j 指向这个新匹配的位置
    }
    Next[i] = j;
  }
}
// KMP 算法，使用定义二的 next 数组，判断 P 是否是 T 的子串
// 若是，则返回 P 首次在 T 中出现的位置；否则，返回-1
int KMP(string T, string P)
{
  int tLen = T.length(); // 文本串的长度
  int pLen = P.length(); // 模式串的长度
  int *Next = new int[pLen];
  getNext(Next, P); // 计算模式串的 Next 数组
  int j = 0;        // 初始化 j=0 表示从模式串的左边第一个字符开始匹配
  for (int i = 0; i < tLen; i++)
  { // 试图用 P[j] 匹配 T[i]
    while (j > 0 && T[i] != P[j])
    {
      j = Next[j] + 1; // 不断回退，直到 j==0 或者 T[i]==P[j]
    }
    if (T[i] == P[j])
    {
      j++; // T[i] 与 P[j] 匹配成功，令 j+1
    }
    if (j == pLen)
    {                      // P 完全匹配，说明 P 是 T 的子串
      return i + 1 - pLen; // 返回首次出现时的位置
    }
  }
  return -1; // 执行完 T 都没匹配成功，匹配失败，返回 -1
}
```