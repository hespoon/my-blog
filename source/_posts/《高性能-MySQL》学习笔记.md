---
title: 《高性能 MySQL》学习笔记
date: 2020-01-30 20:36:55
tags:
---
# 第一章
## 事务的四种隔离级别

1. Read Uncommitted
事务中的修改对其他事务可见。事务可读取未提交的数据，导致脏读。性能上不比其他隔离级别好太多。一般不使用。
脏读是指，事务读取了未提交的数据。
2. Read Commit
大多数数据库系统的默认隔离级别。MySQL 不是。满足隔离性的定义。事务提交之前对其他事务不可见。也称为不可重复读 Nonrepeatable Read。
不可重复读是指，执行两次同样的查询，可能会得到不同的结果。
4. Repeatable Read
无脏读问题。保证在同一个事务中，多次读取同样记录的结果是一致的。存在幻读问题。
幻读是指，一个事务 A 在读取某一范围内的数据后，另一事务 B 在该范围内插入了新数据，事务 A 再次读取该范围内的数据时，会产生幻行。InnoDB 和 XtraDB 通过多版本并发控制解决了幻读问题。
可重复读是 MySQL 的默认事务隔离级别。
5. Serializable 可串行化
最高的隔离级别。强制事务串行处理。会在读取每一行数据时都加上锁，可能导致大量超时和锁争用问题。很少使用该级别。
|隔离级别|是否会脏读|是否会不可重复读|是否会幻读|读时是否加锁|
|-------|-------|----------|--------|----------|
|Read Uncommitted|是|是|是|否|
|Read Commit|否|是|是|否|
|Repeatable Read|否|否|是|否|
|Serializable|否|否|否|是|
> SQL 关键字不区分大小写

## 死锁

* 死锁是指，两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

* InnoDB 目前处理死锁的方法是，将持有最少行级排他锁的事务回滚。
* 锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有的存储引擎会产生死锁，有的则不会。死锁产生有双重原因：真正的数据冲突和存储引擎的实现方式。
* 死锁产生后，只有部分或者完全回滚一个事务才能打破死锁。

## 事务日志

* 存储引擎在修改数据时，只需要修改内存拷贝，再把修改行为记录到持久在硬盘上的事务日志中，不用每次都将修改的数据持久到磁盘。
* 事务日志采取追加的方式，写日志操作是在磁盘上一小块区域内的顺序 I/O。
* 日志持久后，内存中被修改的数据可以在后台慢慢的刷回硬盘。这种方式被称为预写式日志，修改数据需要两次写磁盘。

## 两阶段锁协议

* 在事务执行的过程中，随时都可以加锁。锁只有在执行 COMMIT 或者 ROLLBACK 时才会释放，并且所有的锁在同一时刻释放。InnoDB 会根据隔离级别在需要的时候自动加锁。
* 两阶段锁协议是为了保证事务的隔离性。 

