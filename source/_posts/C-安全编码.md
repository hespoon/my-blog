---
title: C++ 安全编码
date: 2020-10-08 21:49:39
tags:
---

# 整数

以函数封装的形式调用安全函数，降低了代码的可读性，会引发误用风险

不能用立即数充当 destMax，这会导致代码不明确

destMax 一定要正确填写为目的缓冲区的长度

安全函数的返回值是保证安全性的一部分，一般情况下不能忽略对返回值的检查

有符号整数的溢出可能会导致符号变化，无符号整数的溢出会导致大数变小数。

C++ 和 C 中的溢出是未定义的行为，是不能基于溢出结果做假设的。

整数溢出可以被利用做 DoS 和 执行任意代码

大整数强制转换类型时，如果该大整数超出了新的类型可表示的最大值，会发生截断，导致失真

当有符号数强制转换为无符号数时，必须考虑范围问题。比如一个负的有符号数强制转换为一个无符号数时，会得到一个超大的无符号数，引发意想不到的结果。

将整形表达式赋值给较大类型前，没有显示转换为较大类型，会造成数据溢出。

对有符号整数进行位操作可能会出现数据反转。

C 语言标准中制定了 uintptr_t 来表示指针的整数类型。

# 内存

危险操作

内存拷贝时未判断目标内存长度的有效性

内存申请后未判断返回值

使用已经释放的内存

调用不匹配的内存管理操作，new、delete 和 malloc、free 混用

重复释放内存

windows 使用一个双向链表管理管理正在使用的堆内存

当程序中申请 10 字节的堆内存时，实际耗费了 20 字节的物理内存，其中各部分组成如下：

1. 分配内存头，包含一个前向指针和一个后向指针，共占用 8 字节
2. 分配内存体，按照 4 字节对齐原则，分配给申请者 12 字节的内存

 

指针在定义时要初始化，内存在分配后要立即初始化。分配内存后不初始化，可能导致内存中原有的信息泄露。

 

访问以释放的内存的危险主要分为两种的情况：

1. 堆内存：一块内存释放后，就归还给了内存池，就不应该再访问了。这块内存可能被其他代码申请使用，通过原来的指针访问这块内存可能导致其他使用该内存的函数功能不正常。因此，内存释放后要及时将指针置为 nullptr 或指向其他有效内存。
2. 栈内存：函数执行时的临时变量存储在栈上，如果函数将临时变量的地址返回了，则可能导致程序崩溃或者执行恶意代码。

 

重复释放内存可能会导致管理堆内存的双向链表发生混乱，产生不可预计的错误。

 

申请内存之前要检验表示被申请内存大小的整数值，否则会出现下列三种可能的错误：

1. 使用 0 字节长度申请内存的行为是没有意义的
2. 若申请的内存长度大于最大值，则可能导致内存申请失败，造成 DoS
3. 若使用负数长度申请内存，负数会被隐式转换为一个很大的无符号整数，同样可能导致内存分配失败。

 

申请内存后要检查是否申请成功

 

不应当使用 alloca 函数申请内存。

因为 alloca 函数是在栈上申请内存的，而栈一般很小，很容易耗尽，而且分配的内存很容易越过栈的边界而无法预知。

POSIX 和 C99 中均未定义 alloca 的行为。

应当与 malloc 申请内存，然后用 memset_s 函数初始化内存。

 

应当尽量少的使用 realloc 函数调整内存大小。

realloc 函数实现非常复杂，功能不单一，不是一个好的函数实现。

realloc 函数原型如下：

 

void* realloc(void* ptr, size_t size)

 

参数不同，realloc 函数的行行为也不同：

* 当 ptr !=     nullptr && size != 0 时，realloc 会重新调整内存大小，并返回指向新内存的指针。调整后内存中的内容与新旧两块内存大小较小者保持一致。如果是将原内存调大，而申请新的内存失败了，则返回 nullptr，并且保持原内存有效，依旧可以通过 ptr 访问原内存。
* 当 ptr ==     nullptr && size !=0 时，realloc 相当于 malloc(size)。
* 当 size ==     0 时，C++98 中相当于 free(ptr)，C++11 中则是一种未定义的行为。

# 不安全函数

不安全函数包括未指定目的缓冲区大小的内存操作函数和各种容易用错的函数。

 

可能导致命令注入的函数

\#include \<cstdlib>

int system(const char* command);

 

system 函数可以调起命令解析器执行命令。

command 为 nullptr 时，该函数用于检查是否可以成功调起命令解释器，如果调起成功，则返回一个非零值，失败则返回零。

command 不为 nullptr 时，该函数用于执行命令，返回值与 system 函数的实现有关。

 

\#include \<cstdio>

FILE* popen(const char* command, const char* type);

 

popen() 会调用 fork() 产生子进程，然后从子进程中调用 /bin/sh -c 来执行参数 command 的指令。参数 type 的可取值为 "r" 和 "w"。"r" 代表读取，"w" 代表写入。依据 type 的值，popen() 会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可以利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输出设备中。

 

不应当使用外部输入的参数作为命令直接执行或者直接拼接到命令中执行。如果必须要使用，则要对外部输入做白名单校验或者做硬编码。

 

使用 Win32 API 中的 CreateProcess() 函数或者 POSIX 的 exec 系列函数代替 system 函数。

如果使用 system 函数，则应使用硬编码的函数入参或对外部输入中的命令分隔符进行过滤或转义。

 

多线程下的线程不安全函数

这些函数中可能有静态变量或者全局变量，导致函数不可重入。

执行的时序不同，函数的执行结果也可能不同。

1. 函数 strtok 使用了一个静态局部变量标记当前位置，导致不可重入。printf 和 cout 混用，printf 和 cout 在 C++ 标准下是同步的，但是有的编译器可能没有按照标准来处理，所以混用 printf 和 cout 可能发生因时序导致的错误。
2. 信号处理程序中使用异步不安全函数，比如 I/O 函数，自定义的异步不安全函数等。这会造成信号阻塞，使程序执行结果不可预测。

使用 strtok_r 代替 strtok，或者华为的 strtok_s 代替 strtok

 

异步信号安全

异步信号安全操作可以保证不会干扰正被中断的操作。

当信号处理程序干扰正被中断的操作时，就会引发异步信号安全问题。

在信号处理程序与正被同步的操作之间执行的任何同步尝试都将立即产生死锁。

 

获取安全随机数

Unix/Linux 下可以读取 /dev/random 文件获取安全随机数

Windows 使用随机数生成函数 CryptGenRandom() 生成安全随机数

使用开源组件 openssl 获取安全随机数

使用华为的 iPSI 组件

# 文件操作

常见问题

* 文件操作返回值判断有误
* 文件创建时没有指定合适的文件权限
* 对文件的路径校验不够完全

尽量使用文件句柄作为文件的操作对象。

std::string 是不适合用来保存敏感信息的。

 

C 中的 realpath 函数

\#include <limits.h>

\#include <stdlib.h>

char* realpath(const char *path,char *resolved_path)

realpath()函数用来将参数 path 所指的相对路径转换为绝对路径后存与参数 resolved_path 所指的字符串数组或指针中

成功则返回指向 resolved_path 的指针，失败则返回 NULL，错误代码存于 errno 中

该函数可能存在缓冲区溢出的风险。

 

malloc 是线程安全的。malloc 在访问内存链表时会加锁。