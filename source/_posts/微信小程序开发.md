---
title: 微信小程序开发
date: 2020-01-04 00:58:50
tags:
---
* 微信 Web 资源离线存储是面向 Web 开发者提供的基于微信内的 Web 加速方案。通过使用微信离线存储，Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有 Web App 累计最多可缓存 5M 的资源。
* 网页开发渲染线程和脚本线程是互斥的，长时间的脚本运行可能会导致页面失去响应。小程序中，渲染线程和脚本线程是相互独立的。
* 如何编写小程序的一个页面，以 index 为例
1. pages/index 下一般会包含四种文件。分别为 index.json、index.wxml、index.wxss、index.js。
2. 微信客户端首先根据 index.json 配置生成一个界面，界面顶部的颜色和文字在这里面定义。
3. 然后，微信客户端装载页面的 wxml 结构和 wxss 样式。
4. 最后装载 js 文件。
* 使用 Page 构造简单页面。使用 Component 构造复杂页面。
* wxml 中的属性是大小写敏感的
* 列表渲染
    1. 在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项数据重复渲染该组件。数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item。
    2. 使用 wx:for-item 指定数组当前元素的变量名，使用 wx:for-index 指定数组当前项下标的变量名。
    3. wx:key 如果列表中项目的位置会动态改变挥着有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态，如 \<input/> 中输入的内容，\<switch/> 的选中状态，需要使用 wx:key 来指定列表中项目的唯一的标识符。wx:key 的值以一下两种形式提供：
        1. 字符串。即 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
        2. 保留关键字 this。此时，要求 item 本身在 for 循环的 array 中是一个唯一的字符串或者数字。
    4. 当数据改变触发渲染层重新渲染是，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保组件保持自身的状态，并且提高列表渲染时的效率。
* setData 函数用于将数据从逻辑层发往视图层（异步），同时改变对应的 this.data 的值（同步）。
    1. ==直接修改 this.data 而不调用 setData 函数是无法改变页面状态的，还会造成数据不一致。==
    2. 仅支持设置可 JSON 化的数据。
    3. 单次设置的数据不可超过 1024kB，尽量避免一次设置过多的数据
    4. 不要把 data 中任何一项的 value 设置为 undefined，否则这一项将不被设置并可能会出现玄学 bug。
* wxml 文件引用 
    1. import
    使用 import 在 A 文件中引用 B 文件时，可以在 A 文件中使用 B 文件定义的 template。import 没有递归的特性。例如：C import B，B import A。在 C 中可以使用 B 中定义的 template，在 B 中可以使用 A 中定义的 template，但是，不能在 C 中使用 A 中定义的 template。
    2. include
    include 可以将目标文件中除了 \<template/> 和 \<wxs/> 以外的整个代码引入，相当于是拷贝到 include 的位置。
* wxss 分为项目公共样式、页面样式和其他样式三种。
    1. 项目公共样式
    根目录的 app.wxss 为项目公共样式，会被注入到小程序的每个页面。
    2. 页面样式
    与 app.json 注册过的页面同名且位置同级的 wxss 文件。
    3. 其他样式
    其他样式可以被项目公共样式和页面样式引用。
* wxss 的尺寸单位 rpx（responsive pixel）新的尺寸单位用于适配不同宽度的屏幕。
* wxss 样式引用 
格式 @import './test.wxss'
wxss 最终会编译打包到目标文件中，用户只需要下载一次，在使用过程中不会因为样式的引用而产生多与的文件请求。
* 小程序中的 JavaScript 是由 ECMAScript 以及小程序框架和小程序 API 组成的。同浏览器中 JavaScript 相比，没有 BOM 和 DOM 对象，所以类似 JQuery、Zepto 这种浏览器类库是无法使用的。与 NodeJS 中的 JavaScrpit 相比，缺少 Native 模块和 NPM 包管理机制，因此，小程序中无法加载原生类库，也无法直接使用大部分 NPM 包。 
* JS 脚本模块化
小程序可以将任何一个 JavaScript 文件作为一个模块，通过 module.exports 或者 exports 对外暴露接口。通过 require(path) 引入模块。
* 脚本的执行顺序
小程序的执行入口文件是 app.js。会根据其中 require 的模块顺序决定文件的运行顺序。当 app.js 执行结束后，小程序会按照开发者在 app.json 中定义的 pages 的顺序逐一执行。
* 变量作用域
小程序脚本的作用域同 NodeJS 更为相似。在文件中声明的变量和函数只在该文件中有效，不同的文件可以声明相同名字的变量和函数，不会互相影响。
* 全局变量
当需要使用全局变量时，通过使用全局函数 getAPP() 获取全局的实例，并设置相关属性值，来达到设置全局变量的目的。当需要保证全局的数据可以在任何文件中安全的被使用时，可以在 App() 中设置该全局变量。
# 渲染层和逻辑层
1. 渲染层和数据相关
2. 逻辑层负责产生和处理数据
3. 逻辑层通过 Page 实例的 setData 方法传递数据到渲染层
* 渲染层使用 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS 脚本。
* 数据驱动
wxml 先转换为 JS 对象，然后在渲染出真正的 DOM 树。
* 双线程下的界面渲染
小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会吧 wxml 转换成对应的 JS 对象，在逻辑层发生数据变更是，我们需要通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的 DOM 树上，渲染出正确的 UI 界面。
* 程序构造器 App()
宿主环境提供 App() 构造器来注册一个程序 App，App() 构造器必须写在项目根目录的 app.js 中。App 实例是单例对象，在其他 JS 脚本中使用宿主环境提供的 getApp() 方法获取程序实例。App 构造器接受一个 Object 参数。
# 程序的生命周期与打开场景
* 程序的生命周期是由微信客户端根据用户操作主动触发的。为了避免程序上的混乱，我们不应该从其他代码里主动调用 App 实例的生命周期函数。
* 初次进入小程序时，微信客户端初始化好宿主环境，同时从网络下载或者从本地缓存中拿到小程序的代码包，把它注入到宿主环境中。
* 初始化完毕后，微信客户端会给 App 实例派发 onLaunch 事件，App 构造器参数所定义的 onLaunch 方法会被调用。
* 进入小程序后，用户可以点击右上角的关闭，或者按手机设备的 Home 键离开小程序，此时小程序并没有被直接销毁，而是进入后台状态，App 构造器参数所定义的 onHide 方法会被调用。
* 再次回到微信或者再次打开小程序时，微信客户端会把后台的小程序唤醒，这种状态称为“小程序进入前台状态”，App 构造器参数所定义的 onShow 方法会被调用。
* 打开小程序有很多途径，针对不同的打开途径，小程序有时需要做不同的业务处理。微信客户端会把打开方式传递给 onLaunch 和 onShow 的调用参数 options。options 是一个对象。
* 不同页面的 JS 脚本运行在同一个 JsCore 中。当一个页面使用 setTimeout 或者 setInterval 的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开时进行处理。
* App 实例是单例的，因此可以通过 App 实例下的属性来共享数据。
# 页面
* 一个页面由三部分组成：界面、配置和逻辑。
    * 界面由 wxml 和 wxss 文件来负责描述
    * 配置由 JSON 文件进行描述
    * 页面逻辑由 JS 脚本负责
* 同一个页面的文件需要放在同一目录下。其中，wxml 和 JS 文件是必须存在的，JSON 和 wxss 文件是可选的。
* 页面路径需要在小程序代码根目录的 app.json 的 pages 字段声明，否则这个页面不会被注册到宿主环境中。
# 页面构造器 Page()
* 宿主环境提供 Page() 构造器来注册一个小程序页面，Page() 在页面脚本中调用。Page 构造器接受一个 Object 参数。
* 页面的生命周期函数中 onLoad 早于 onShow 早于 onReady。
# 页面的生命周期
* 页面初次加载时，宿主环境会给 Page 实例派发 onLoad 事件，onLoad 方法被调用。onLoad 在页面销毁之前只会触发一次。在 onLoad 的回调中，可以获取当前页面所调用的打开参数。
* 页面显示后，调用 onShow 方法。一般从别的页面返回当前页面时，当前页的 onShow 方法会被调用。
* 页面初次渲染完成时，onReady 方法会被调用。onReady 方法在页面没被销毁前只会触发一次。onReady 触发时，表示页面已经准备妥当，在逻辑层就可以和视图层进行交互了。
* 页面不可见时，onHide 方法被调用。在使用 wx.navigateTo 切换到其他页面或底部 tab 切换时触发。
* 当前页面使用 wx.redirectTo 或 wx.navigateBack 返回其他页面时，当前页面会被微信客户端销毁回收，此时触发 onUnload 方法。
* Page 的生命周期是由微信客户端根据用户操作主动触发的，为了避免程序上的混乱，我们不应该在其他代码中主动调用 Page 实例的生命周期函数。
# 页面打开参数 query
* 小程序把页面的打开路径定义为页面 URL，其组成格式和网页 URL 类似，在页面路径后使用英文 ? 分隔 path 和 query部分。query 部分的多个参数使用 & 分隔，参数的名字和值使用 key=value 的形式声明。在 Page 构造器的 onLoad 的 option 中可以拿到当前页面的打开参数，其类型是一个 Object，其键值与页面 URL 上 query 键值一一对应。和网页 URL 相同，页面 URL 的 value 如果涉及特殊字符，需要采用 UrlEncode 后再拼接到页面 URL 上。
# 页面的数据
* wxml 通过数据绑定的语法绑定从逻辑层传递过来的数据字段。数据来源于页面 Page 构造器的 data 字段，data 参数是页面第一次渲染时从逻辑层传递到渲染层的数据。
* 宿主环境提供的 Page 实例的原型中有 setData 函数，我们可以在 Page 实例下的方法中调用 this.setData 把数据传递给渲染层，从而达到更新界面的目的。
* 由于小程序的渲染层和逻辑层分别在两个线程中运行，所以 setData 传递数据是一个异步的过程。因此，setData 的第二个参数是一个 callback 回调，回调在这次 setData 对页面渲染完毕后触发。
* setData 的一般调用格式是 setData(data,callback)。其中，data 是由多个 key:value 构成的 Object 对象。
* 每次只设置需要改变的最小单位的数据可以提高小程序的渲染性能。
1. ==直接修改 this.data 而不调用 setData 函数是无法改变页面状态的，还会造成数据不一致。==
2. 仅支持设置可 JSON 化的数据。
3. 单次设置的数据不可超过 1024kB，尽量避免一次设置过多的数据。因为 setData 需要两个进程之间通信。
4. 不要把 data 中任何一项的 value 设置为 undefined，否则这一项将不被设置并可能会出现玄学 bug。
# 页面的用户行为
1. 下拉刷新 onPullDownRefresh
监听用户下拉刷新事件，需要在 app.json 的 window 选项中或页面配置 page.json 中设置 enablePullDownRefresh 为 true。当处理完数据刷新后，wx.stopPullDownRefresh 可以停止当前页面的下拉刷新。
2. 上拉触底 onReachBottom
监听用户上拉触底事件。可以在 app.json 的 window 选项中或页面配置 page.json 中设置触发距离 onReachBottomDistance。在触发距离内滑动期间，本事件只会被触发一次。
3. 页面滚动 onPageScroll
监听用户滑动页面事件，参数为 Object，包含 scrollTop 字段，表示页面在垂直方向已滚动的距离（单位px）。
4. 用户转发 onShareAppMessage
只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮，在用户点击转发按钮的时候会调用，此事件需要 return 一个 Object，包含 title 和 path 两个字段，用于自定义转发内容。
# 页面跳转与路由
* 一个小程序拥有多个页面，我们可以通过 wx.navigateTo 推入一个新的页面。多次推入后会形成一个页面栈，当前页面在栈顶。页面栈有最大层级的限制。
* 当页面栈到达最大层级没法新增时，使用 wx.redirectTo 进行页面跳转。
* wx.navigateTo 和 wx.redirectTo 只能打开非 TabBar 页面，wx.switchTab 只能打开 TabBar 页面。
* wx.reLaunch 用于重启小程序
* TabBar 页面初始化后在页面路由的过程中不会被销毁。
# 组件
* 所有组件名和标签名都是小写，多个单词会以英文 - 连接。
* 组件有公共属性和自定义属性。
* 懒加载也叫延迟加载，指的是在网页中延迟加载图像，是一种很好的优化网页性能的方式。用户滚动到它们之前，可视区域外的图像不会加载。
* 预加载。预加载是另一种性能优化技术，可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。预加载简单来说是将所有需要的资源提前请求加载到本地，在后面用到时就直接从缓存中取资源。
# API
* API 通常是指 wx 对象下的方法。
* wx.on* 开头的 API 是监听某个事件发生的 API 接口，接受一个 Callback 函数作为参数。当该事件触发时，会调用 Callback 函数。
* 如未特殊约定，多数 API 接口为异步接口 ，都接受一个 Object 作为参数。
* API 的 Object 参数一般由 success、fail、complete 三个回调来接收接口调用结果。
* wx.get* 开头的 API 是获取宿主环境数据的接口。
* wx.set* 开头的 API 是写入数据到宿主环境的接口。
# 事件
* 用户在渲染层的行为反馈以及组件的部分状态反馈抽象为渲染层传递给逻辑层的事件。
* 事件冒泡与事件捕获
事件冒泡与事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流的问题。
```HTML
<html>
    <body>
        <div id="outer">
            <p id="inner">Click me!</p>
        </div>
    </body>
</html>
```
* 考虑上述代码，假设 outer div 和 inner p 各自都有一个 click 处理函数，那么我们怎么才能知道哪一个函数会首先触发？
* 事件冒泡
微软提出的事件冒泡的事件流。事件冒泡可以形象的比喻为把一个石头投入水中，泡泡会一直从水底冒出水面。因此，事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。因此，在事件冒泡的概念下，在 p 元素上发生的 click 事件的顺序应该是 p->div->body->html->document
* 事件捕获
网景提出的另一种事件流名为事件捕获。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。因此，在事件捕获的概念下，在 p 元素上发生的 click 事件的顺序应该是 document->html->body->div->p
* w3c 指定的统一的标准，事件应当先捕获再冒泡。
* 注意 currentTarget 和 target 的区别。currentTarget 是当前事件所绑定的组件。target 是触发该事件的源头组件。
# 事件绑定
* 事件绑定的写法与组件属性一致，以 key="value" 的形式。
    * key 以 bind 或者 catch 开头，然后跟上事件类型。如 bindtap，catchtouchstart。bind 和 catch 后可以紧跟一个冒号，含义不变。例如，bind:tap，catch:touchstart。可以在 bind 和 catch 前面加上 capture- 来表示捕获阶段。
    * value 是一个字符串，对应于 Page 中定义的同名函数。若未定义该函数，则触发事件时会在控制台产生报错信息。
    * bind/catch 代表事件的冒泡阶段；capture-bind/capture-catch 表示事件的捕获阶段。
* bind 事件绑定不会阻止冒泡事件向上冒泡。catch 事件绑定可以阻断事件传递，中断捕获阶段和阻止冒泡事件向上冒泡。
* 除下表所列事件类型之外的其他组件自定义事件，如无特殊说明，则都是非冒泡事件。

|事件类型|触发条件|
|----|------|
|touchstart|手指触摸动作开始|
|touchmove|手指触摸后移动|
|touchcancel|手指触摸动作被打断，如来电提醒，弹窗|
|touchend|手指触摸动作结束|
|tap|手指触摸后马上离开|
|longpress|手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发|
|longtap|手指触摸后，超过350ms再离开（推荐使用longpress事件代替）|
|transitionend|会在 WXSS transition 或 wx.createAnimation 动画结束后触发|
|animationstart|会在一个 WXSS animation 动画开始时触发|
|animationiteration|会在一个 WXSS animation 一次迭代结束时触发|
|animationend|会在一个 WXSS animation 动画完成时触发|

# 兼容
* 通过 wx.getSystemInfo 或者 wx.getSystemInfoSync 来获取设备信息。包括手机品牌，操作系统版本，微信版本号以及小程序基础库版本号等。
* 通过判断 API 是否存在来做兼容。
* 通过 wx.canIUse 来判断接口或者组件在当前宿主环境是否可用。
* 通过在小程序管理后台设置基础库最低版本来达到不向前兼容。
# 开发基本流程
1. 确定产品体验，使用交互图或者手稿描绘小程序的界面交互和界面之间的跳转。
2. 完成 wxml 和 wxss 还原设计稿。
3. 填充 wxml 的模版语法，完成 js 逻辑。
# Flex 布局
* 采用 flex 布局的元素，简称为容器。容器内的元素简称项目。
* flex 使容器能通过改变里面项目的高宽、顺序，来对可用空间实现最佳填充，方便配饰不同大小的内容区域。
* flex 不单是一个属性，它包含了一套新的属性集。属性集包括用于设置容器和用于设置项目两部分。
* 坐标轴。默认情况下，水平方向是主轴（main axis），垂直方向是交叉轴（cross axis）。
* 项目在主轴上排列，排满后在交叉轴方向换行。交叉轴垂直于主轴，它的方向取决于主轴方向。
1. 容器属性。设置容器属性，用于统一管理容器内项目布局，即项目的排列方式与对齐方式。
    * display 属性
    使用 flex 布局时，display 属性值为 flex。
    * flex-direction 属性
    通过设置坐标轴，来设置项目排列方向。
    默认值为 row。
    * flex-wrap 属性
    设置是否允许项目多行排列，以及多行排列时的换行方向。
    默认值为 nowrap
    * justify-content 属性
    设置项目在主轴方向上的对齐方式，以及分配项目之间及其周围多余的空间。
    默认值为 flex-start
    * align-items 属性
    设置项目在行中的对齐方式。
    默认值为 stretch。
    * align-content 属性
    多行排列时，设置行在交叉轴方向上的对齐方式，以及分配行之间及其周围多余的空间。
    默认值为 stretch。
2. 项目属性。设置项目的尺寸、位置以及对项目的对齐方式做特殊设置。
    * order 属性
    设置项目沿主轴方向上的排列顺序，数值越小，排列越靠前。属性值为整数。
    默认值为 0。
    * flex-shrink 属性
    当项目在主轴方向上溢出时，通过设置项目收缩因子来压缩项目，使之适应容器。
    属性值为项目的压缩因子，属性值取非负数，默认值为 1。
    项目溢出=各项目宽度之和-容器宽度
    总权重=∑(各项目的宽度×各自的flex-shrink)
    当各项目的压缩因子之和小于 1 时，溢出空间=项目溢出×压缩因子之和
    当各项目的压缩因子之和大于等于 1 时，溢出空间=项目溢出
    项目最终宽度=原始宽度-溢出空间×原始宽度×压缩因子÷总权重
    * flex-grow 属性
    当项目在主轴方向上还有剩余空间时，通过设置项目扩张因子进行剩余空间的分配。
    属性值为项目的扩张因子，属性值取非负数，默认值为 0。
    项目剩余空间=容器宽度-项目宽度之和
    当项目扩张因子之和大于 1 时，剩余空间分配=项目剩余空间÷扩张因子之和
    当项目扩张因子之和小于 1 时，剩余空间分配=项目剩余空间
    项目最终宽度=原始宽度+(剩余空间分配×扩张因子)
    * flex-basis 属性
    当容器设置 flex-direction 为 row 或 row-reverse 时，flex-basis 和 width 同时存在，flex-basis 优先级高于 width，也就是此时 flex-basis 代替项目的 width 属性。
    当容器设置 flex-direction 为 column 或 column-reverse 时，flex-bais 与 height 同时存在，flex-basis 的优先级高于 height，也就是此时 flex-basis 代替 项目的 height 属性。
    当 flex-basis 或 width 或 height 其中一个属性值为 auto 时，非 auto 的优先级更高。
    flex-basis 的默认值为 auto。
    * flex 属性
    是 flex-grow、flex-shrink 和 flex-basis 的简写方式。
    值为 none 时，等价于 flex-grow:0 flex-shrink:0 flex-basis:auto
    值为 auto 时，等价于 flex-grow:1 flex-shrink:1 flex-basis:auto
    * align-self 属性
    设置项目在行中交叉轴方向上的对齐方式，用于覆盖容器的 align-items 属性，这样可以对项目的对齐方式做特殊处理。默认值为 auto，此时继承容器 align-items 的值。当容器没有设置 align-items 时，align-self 的属性值为 stretch。
## flex 的 grow shrink 和 basis
* min-content 和 max-content
当一个文本段设置了 `width:min-content` 时，在支持该关键字的浏览器中，该文本会尽可能地抓住机会来自动换行，变得尽可能的小且没有溢出。本质上来讲，文本段中最长的单词决定了该文本短的宽度。
当一个文本段设置了 `width:max-content` 时，该文段的表现与 `min-content` 完全相反，它会变得尽可能的大，不会自动换行。如果承载它的容器太窄，它就会溢出自身的盒子。
* positive and negative free space
Flex 布局中有 flex 容器和 flex 子元素，子元素包含在容器中，当 flex 子元素在主轴上的尺寸之和小于 flex 容器的主轴方向上的尺寸时，flex 容器中就会有多余的空间没有被填充，这些空间叫做 positive free space。当 flex 子元素在主轴上的尺寸之和大于 flex 容器的尺寸时，flex 容器的空间就不够用，此时，flex 子元素的尺寸之和减去 flex 容器的尺寸就是 negative free space。 
* flex-basis
flex-basis 属性在任何空间分配发生之前，初始化 flex 子元素的尺寸。此属性的初始值为 auto。如果 flex-basis 设置为 auto，浏览器会先检查 flex 子元素的主尺寸是否设置了绝对值，然后再计算出 flex 子元素的初始值。比如：主轴为 row，flex 子元素的宽被设置为 200px，则 200px 就是该 flex 子元素的 flex-basis。
当 flex-basis 为 auto 且 子元素没有设置宽度时，flexbox 会将 flex 子元素的 max-content 的大小作为 flex-basis。
flex-basis 还可以用 content 作为 flex-basis 的值，这会导致 flex-basis 根据内容的大小设置，即使 flex 子元素设置了宽度。
flex-basis 为 0 时，flex 容器完全忽略 flex 子元素的尺寸。初始时，子元素的大小都为零，容器的所有空间都可以用于分配。
* flex-grow
该属性决定了当 positive free space 分配时，flex 子元素相对于 flex 容器中的其余 flex 子元素的增长程度。
所有子元素的 flex-grow 只都相同时，positive free space 平均分配给所有子元素。
flex-grow 为 0 时，表示不允许子元素被拉伸，分配 positive free space 时不分配给它。
* flex-shrink
该属性决定在分配 negative free space 时，flex 子元素相对于 flex 容器中其他 flex 子元素的收缩程度。
flex-shrink 为 0 时，表示不允许子元素收缩。
所有的子元素的 flex-shrink 都为 1 时，每个子元素都收缩同样大小的量。
在 negative free space 消除期间，flex 容器会阻止小的 flex 子元素缩小到 0。这些 flex 子元素的大小会被设置为 min-content。
flex 子元素收缩后，其大小绝不会小于 min-content。
flex-shrink 的值越大，该子元素收缩的越快。

# 常见的交互反馈
* 触摸反馈
view 容器组件和 button 组件提供了 hover-class 属性，触摸时会向该组件加上对应的 class 改变组件的样式。
当点击 button 按钮处理更耗时的操作时，使用 button 的 loading 属性，在按钮文字前边出现一个 Loading，让用户明确的感觉到该操作很耗时。
* Toast 和模态对话框
使用弹出式提示 Toast 提醒用户。Toast 提示默认 1.5 秒后自动消失。Toast 不应用于错误提示。
使用模态对话框提示用户操作结果状态，或者错误等需要用户思考的信息。
* 界面滚动
下拉整个页面触发刷新。
"enablePullRefresh":true
上拉触底
界面下方距离页面底部距离小于 onReachBottomDistance 像素时触发 onReachBottom 回调。
使用 scroll-view 组件实现页面中某一小块区域滚动。
disableScroll 设置为 true 则页面整体不能上下滚动。只在页面配置中有效，无法在 app.json 中设置。
# 发起 HTTPS 网络通信
* 使用 wx.request 发起网络通信
* request 发起的请求必须是 https 协议请求。
* 请求的域名需要在小程序管理平台进行配置，如果小程序正式版使用 request 请求未配置的域名，在控制台会有报错。
* 小程序的开发版，小程序的体验版和开发者工具在某些情况下允许 request 请求任意域名。
* 如果接口需要支持新的特性需要修改返回的数据格式，那接口的参数和返回字段至少向前兼容一个版本。
* 请求参数
通过 URL 的 query 传递请求参数或者通过 data 属性传递请求参数。由于 URL 有长度限制，其最大长度为 1024B，同时 URL 上的参数需要拼接到字符串中，参数的值还要做一次 urlEncode。当向服务器发送的请求参数超过 1024B 时，就要采用 HTTPPost 的形式，此时，传递的请求参数就必须要使用 data 属性。因此，一般建议需要传递请求参数时都使用 data 属性。
当使用 POST 请求时，有时需要传递较复杂的数据结构到后台，此时使用 JSON 格式会更合适。此时，可以在 wx.request 的 header 参数设置 content-type 头部为 application/json，此时，小程序发起请求的包体内容就是 data 参数对应的 JSON 字符串。
* 收到回包
小程序端收到回包后会触发 success 回调，同时回调会带上一个 Object 信息。只要成功收到服务器返回，无论 HTTP 的状态码是多少都会进入 success 回调。因此开发者应当自己判断返回码，然后再执行后续的业务逻辑。
success 回调参数的 data 字段类型是根据 header['content-type'] 决定的。header['content-type'] 默认为 application/json。在触发 success 回调前，小程序宿主环境会对 data 字段的值做 JSON 解析，如果解析成功，那么 data 字段的值会被设置成解析后的 Object 对象，其他情况 data 字段都是 String 类型，其值为 HTTP 回包包体。
* 设置请求超时
request 的请求超时默认为 60 秒。可以在 app.json 中通过 networkTimeout 指定 request 请求超时时间。
* 请求前后的状态处理
为了防止用户极快的点击两次按钮，通过添加 hasClick 的锁。hasClick 初始值为 false。在开始请求之前检查 hasClick 的值，如果为 false 则发起请求并将 hasClick 改为 true，然后在 request 的 complete 回调中将 hasClick 改回 false。
* 请求异常排查方法
1. 检查手机网络状态以及wifi连接点是否工作正常。
2. 检查小程序是否为开发版或者体验版，因为开发版和体验版的小程序不会校验域名。
3. 检查对应请求的HTTPS证书是否有效，同时TLS的版本必须支持1.2及以上版本，可以在开发者工具的console面板输入showRequestInfo()查看相关信息。
4. 域名不要使用IP地址或者localhost，并且不能带端口号，同时域名需要经过ICP备案。
5. 检查app.json配置的超时时间配置是否太短，超时时间太短会导致还没收到回报就触发fail回调。
6. 检查发出去的请求是否302到其他域名的接口，这种302的情况会被视为请求别的域名接口导致无法发起请求。
# 微信登陆
* 如何获取微信登录状态，如何把微信帐号和自己的帐号打通，如何把微信登录应用到小程序中。
* 获取微信登陆凭证 code
如果小程序通过 wx.login 直接从微信服务器获得用户 id，那么黑客可以通过遍历所有 id，把整个业务侧，即第三方服务器上的用户个人信息全部拉走。
为了避免这样的风险，在 wx.login 调用时，微信服务器会生成一个带有时效性的凭证，有效时间为 5 分钟，然后将该凭证返回给小程序方，该凭证成为微信登录凭证 code。然后小程序方将 code 发给自己的服务器，然后通过自己的服务器将该 code 去找微信服务器换取微信用户 id。因为这个临时凭证会在 5 分钟后过期，如果黑客要冒充一个用户的话，那他必须在 5 分钟内穷举所有凭证，然后去开发者服务器换取用户信息。显然，黑客要付出非常大的成本才能获取到一个用户信息。同时，开发者的服务器也可以通过技术手段检测 5 分钟内频繁从某个凭证发来的登陆请求，从而拒绝这些请求。
* 发送 code 到开发者的服务器
在 wx.login 的 success 回调中获得微信登录凭证后，将该凭证通过 wx.request 发往开发者的服务器，以便向微信服务器换取用户微信 id。如果当前微信用户还没有绑定当前小程序业务的用户身份，那在此次请求中应当顺便把用户输入的账号密码一起传到开发者服务器，然后在开发者服务器校验账号密码后再和微信用户 id 绑定。
* 到微信服务器换取微信用户 id
开发者后台拿到微信登陆凭证 code 后，可以向微信服务器换取用户 id。微信服务器为了确保拿 code 换取身份信息的人就是刚刚对应的小程序开发者，开发者后台发向微信服务器的信息应当带上 Appid 和 AppSecret，这两个信息可以在小程序管理平台的开发设置界面找到。
APPID 是公开信息，泄漏不会产生风险。AppSecret 是开发者的隐私数据不应当泄漏。如果发现 AppSecret 泄漏，开发者需要到小程序管理平台重置 AppSecret。微信登录凭证 code 在成功换取一次信息后会立即失效，即使凭证的生成时间还没过期。
开发者服务器和微信服务器之间通信使用 HTTPS 协议，微信服务器的接口为 `https://api.weixin.qq.com/sns/jscode2session?appid=<AppId>&secret=<AppSecret>&js_code=<code>&grant_type=authorization_code`
请求成功后，微信服务器会返回下标信息

|字段|描述|
|----|---|
|openid|微信用户的唯一标识|
|session_key|会话密钥|
|unionid|用户在微信开放平台的唯一标识符，本字段在满足一定条件时才返回。|

* openid 即用户的微信 id，可以用此 id 区分不同的用户。
* session_key 是微信服务器给开发者颁发的身份凭证，开发者可以用 session_key 请求微信服务器的其他接口来获取一些其他信息。session_key 不应该泄漏或下发小程序前端。session_key 与微信登陆凭证 code 相比，是一个较长期的身份凭证。session_key 也存在过期时间。
* 绑定微信用户身份 id 和业务用户身份
当业务侧用户还没绑定微信侧身份时，会让用户填写业务侧用户名与密码，这两个值应当同微信登陆凭证 code 一同发给开发者服务器。开发者后台应当把用户的业务 id 同用户的微信 id 对应关系绑定起来。有了这个绑定信息，小程序在下次需要用户登录时，就可以不需要输入帐号密码，因为通过 wx.login 拿到用户的微信 id 后，通过绑定信息就可以查出业务侧的用户身份 id，这样静默授权的登录方式将非常方便。
* 业务登陆凭证 Sessionid
SessionId 是开发者服务器与开发者的小程序之间的会话密钥。用户登录成功后，开发者服务器会生成会话密钥 SessionId，并在服务端保持 SessionId 对应的用户身份信息，同时把 SessionId 返回给小程序。小程序后续发起的请求中应当携带 SessionId，开发者的服务器可以通过 SessionId 查询到当前登陆用户的身份，这样就不用每次都重新获得 code。还可以利用本地数据缓存的能力把 SessionId 存储在本地，以便在它过期之前重复利用，提高通信的性能。
# 本地数据缓存
* 本地数据缓存是小程序存储在当前设备上硬盘上的数据。本地数据缓存有非常多的用途，我们可以利用本地数据缓存来存储用户在小程序上产生的操作，在用户关闭小程序重新打开时可以恢复之前的状态。我们还可以利用本地缓存一些服务端非实时的数据提高小程序获取数据的速度，在特定的场景下可以提高页面的渲染速度，减少用户的等待时间。
* wx.getStorage 是异步接口，用于读取本地缓存，在 success 回调执行时才能取得返回值。
* wx.getStorageSync 是同步接口，用于读取本地缓存，执行完毕后会立即返回。
* wx.setStorage 是异步接口，用于写入本地缓存，在 success 回调执行时才能知道写入是否成功。
* wx.setStorageSync 是同步接口，用于写入本地缓存，可以立即执行写入操作。
* 不同小程序的本地缓存空间是分开的，每个小程序的缓存空间上限为 10MB。如果达到上限，在通过 wx.setStorage 写入是会触发 fail 回调。
* 同一设备不同用户登陆同一小程序时，不同用户的本地缓存是隔离开的。
* 利用本地缓存提前渲染界面
第一次从服务器拉取信息后可以存放在本地缓存中，当再次使用该信息时，可以直接从本地缓存读取，加快页面渲染。
渲染页面时，首先判断是否存在本地缓存，若不存在，则再向服务器发送请求。
一般在对数据实时性或一致性要求不高的页面采用此种预加载方法。
* 缓存用户登录态 SessionId
通常在用户没有主动退出登录之前，用户的登录状态应当一直保持。如果将 SessionId 简单的存放在一个 JS 变量中，当用户关闭小程序再打开时，之前内存中的 SessionId 已经丢失。因此，应当使用本地缓存来存储 SessionId。
# 设备能力
* 扫码
wx.scanCode 会调起微信扫一扫，success 回调会收到二维码对应的信息。可以利用扫码代替很多繁琐的输入，让小程序变的更加快捷。
* 获取网络状态
wx.getNetworkType 获取网络状态，success 回调的 networkType 属性存放网络状态。
wx.onNetworkStatusChange 可以动态监听网络状态的变化。
# 小程序项目开发流程
* 项目管理成员负责统筹整个项目的进展和风险、把控小程序对外发布的节奏，产品组提出需求，设计组与产品讨论并对需求进行抽象，设计出可视化流程与图形，输出设计方案。开发组依据设计方案，进行程序代码的编写，代码编写完成后，产品组与设计组体验小程序的整体流程，测试组编写测试用例并对小程序进行各种边界测试。
* 建议在项目开发阶段特殊分配一个开发角色，用于上传稳定可供体验测试的代码，并把他上传的开发版本设置成体验版。
* 优秀的用户体验是产品的目标
    1. 导航清晰
    2. 流程明确
    3. 重点突出
    4. 符合预期 降低用户学习成本
    5. 等待与反馈
    6. 异常处理
    7. 内容和文案准确友好
    8. 和谐统一
    9. 平台适配
* 发布前的最后检查
    1. 如果小程序使用到Flex布局，并且需要兼容iOS8以下系统时，请检查上传小程序包时，开发者工具是否已经开启“上传代码时样式自动补全”。
    2. 小程序使用的服务器接口应该走HTTPS协议，并且对应的网络域名确保已经在小程序管理平台配置好。
    3. 在测试阶段不要打开小程序的调试模式进行测试，因为在调试模式下，微信不会校验域名合法性，容易导致开发者误以为测试通过，导致正式版小程序因为遇到非法域名无法正常工作。
    4. 发布前请检查小程序使用到的网络接口已经在现网部署好，并且评估好服务器的机器负载情况。
* 发布模式
全量发布与分阶段发布
还需要留意一点，并非全量发布之后，用户就会立即使用到最新版的小程序，这是因为微信客户端存有旧版本小程序包缓存。用户在使用小程序时会优先打开本地的小程序包，微信客户端在某些特定的时机异步去更新最新的小程序包。一般我们认为全量发布的24小时后，所有用户才会真正使用到最新版的小程序。
# 双线程模型
* Hybrid 技术
界面主要由成熟的 Web 技术渲染，辅之以大量的接口提供丰富的客户端原生能力。每个小程序页面都是用不同的 WebView 渲染，避免了单个 WebView 的任务过于繁重。定义了一套内置组件统一体验。内置组件中有一部分较复杂的组件使用客户端原生渲染的，已提供更好的性能。
* 管控与安全
宿主环境提供一个沙箱环境运行开发者的 JavaScript 代码。该环境没有任何浏览器相关的接口，只提供纯 JavaScript 的解释执行环境，类似于 HTML5 中的 ServiceWorker、WebWorker 特性。得益于客户端系统有 JavaScript 的解释引擎（iOS 下用的是内置的 JavaScriptCore 框架，安卓用的是腾讯 x5 内核提供的 JsCore 环境）。因此可以创建一个单独的线程执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码，也即小程序的逻辑层。而界面渲染相关的任务都在 WebView 线程里执行，通过逻辑层代码去控制渲染那些界面，也即小程序的渲染层。
* 双线程导致的延时
在小程序的双线程模型中，任何数据传递都是线程间通信，也就会有一定的延时。逻辑层的修改与渲染层的渲染是异步的。
异步会使各部分的运行时序变得复杂。比如在渲染首层时，逻辑层与渲染层会同时开始初始化工作，但渲染层需要逻辑层的数据才能把界面渲染出来，如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作。因此，逻辑层与渲染层需要有一定的机制保证时序正确，这些工作由小程序框架完成。
除逻辑层与渲染层之间通信有延时，各层与客户端原生交互同样有延时。以逻辑层为例，开发者的代码是跑在逻辑层这个线程上，而客户端原生跑在微信主线程上（安卓机），所以注册给逻辑层有关客户端能力的接口，实际上也是在跟微信主线程之间的通信，同样意味着有延时。这也是大部分 API 是异步的原因。
# 组件系统
* Exparser 框架
Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。
* 内置组件
小程序基于 Exparser 框架，内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。
* 自定义组件
自定义组件是开发者可以自行扩充的组件。开发者可以将常用的节点树结构提取成自定义组件，实现代码复用。
    1. Shadow Tree
    在 Exparser 的组件模型中，组件节点树和调用组件的节点树可以拼凑出页面节点树。其中，组件节点树称为 Shadow Tree，即组件的内部实现。最终拼凑成的页面节点树称为 Composed Tree，即将页面上所有组件节点树合成之后的树。因此，进行组件分离后，整个页面节点树实质上被拆分为若干 Shadow Tree。
    各个组件具有自己独立的逻辑空间。每个组件都分别拥有自己独立的数据、setData 调用，createSelectorQuery 运行在 Shadow Tree层面上。
    2. 组件运行
    Exparser 接管所有自定义组件注册与实例化。从外部接口上看，小程序基础库提供有 Page 和 Component 两个构造器。以Component为例，在小程序启动时，构造器会将开发者设置的properties、data、methods等定义段，写入Exparser的组件注册表中。这个组件在被其它组件引用时，就可以根据这些注册信息来创建自定义组件的实例。Page构造器的大体运行流程与之相仿，只是参数形式不一样。这样每个页面就有一个与之对应的组件，称为“页面根组件”。
    在初始化页面时，Exparser 会创建出页面根组件的一个实例，用到的其他组件也会响应创建组件实例（这是一个递归的过程）。组件创建的过程大致有以下几个要点：

        1. 根据组件注册信息，从组件原型上创建出组件节点的 JS 对象，即组件的 this；
        2. 将组件注册信息中的 data 复制一份，作为组件数据，即 this.data；
        3. 将这份数据结合组件 WXML，据此创建出 Shadow Tree，由于 Shadow Tree 中可能引用有其他组件，因而这会递归触发其他组件创建过程；
        4. 将 ShadowTree 拼接到 Composed Tree 上，并生成一些缓存数据用于优化组件更新性能；
        5. 触发组件的 created 生命周期函数；
        6. 如果不是页面根组件，需要根据组件节点上的属性定义，来设置组件的属性值；
        7. 当组件实例被展示在页面上时，触发组件的 attached 生命周期函数，如果 Shadw Tree 中有其他组件，也逐个触发它们的生命周期函数。
    3. 组件间通信
    不同组件实例间的通信有 WXML 属性值传递、事件系统、selectComponent 和 relations 等方式。其中，WXML 属性值传递是从父组件向子组件的基本通信方式，而事件系统是从子组件向父组件的基本通信方式。
    Exparser 的事件系统完全模仿 Shadow DOM 的事件系统。在通常的理解中，事件可以分为冒泡事件和非冒泡事件，但在 Shadow DOM 体系中，冒泡事件还可以划分为在 Shadow Tree 上冒泡的事件和在 Composed Tree 上冒泡的事件。如果在 Shadow Tree 上冒泡，则冒泡只会经过这个组件 Shadow Tree 上的节点，这样可以有效控制事件冒泡经过的范围。
    在自定义组件中使用 triggerEvent 触发事件时，可以指定事件的 bubbles、composed 和 capturePhase 属性，用于标注事件的冒泡性质。
* 原生组件
在内置组件中，有一些组件较为特殊，它们并不完全在 Exparser 的渲染体系下，而是由客户端原生参与组件的渲染，这类组件我们称为“原生组件”,这也是小程序 Hybrid 技术的一个应用。
原生组件的层级比所有在 WebView 层渲染的普通组件的层级要高。
交互比较复杂的原生组件都会提供“context”，用于直接操作组件。以 canvas 为例，小程序提供了 wx.createCanvasContext 方法来创建 canvas 的 context。这是一个可以用于操作 canvas 的对象，对象下提供了很多绘图的方法，如“setFillStyle”方法可以设置填充样式，“fillRect”方法用于绘制矩形（这些方法与 HTML DOM Canvas 兼容）。
* 原生组件渲染限制
原生组件脱离在 WebView 渲染流程外，这带来了一些限制。最主要的限制是一些 CSS 样式无法应用于原生组件，例如，不能在父级节点使用 overflow:hidden 来裁剪原生组件的显示区域；不能使用 transformrotate 让原生组件产生旋转等。

开发者最为常见的问题是，原生组件会浮于页面其他组件之上（相当于拥有正无穷大的 z-index 值）使其它组件不能覆盖在原生组件上展示。想要解决这个问题，可以考虑使用 cover-view 和 cover-image 组件。这两个组件也是原生组件，同样是脱离 WebView 的渲染流程外，而原生组件之间的层级就可以按照一定的规则控制。
# 组件的 behaviors
* behaviors 是用于组件间代码共享的特性。每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。 每个组件可以引用多个 behavior ，behavior 也可以引用其他 behavior 。
# 组件的纯数据字段
* 有些情况下，某些 data 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。此时，可以指定这样的数据字段为“纯数据字段”，它们仅仅被记录在 this.data 中，不参与任何界面渲染过程，这样有助于提升页面更新性能。
* 使用组件时，要在 wxml 对应的 json 文件中添加 usingComponents 字段
# 云开发的数据库
* 云开发提供了一个 JSON 数据库。

# 小工具
## 水平分割线
```CSS
.line-between {
  background: #E0E3DA;
  width: 90%;
  height: 3rpx;
  margin: auto; // 水平居中
}
```
