---
title: 深信服培训
date: 2020-06-18 11:32:56
tags:
---

## 工作内容

使用 C 语言实现了一系列构建 JSON 结构的 API，支持 string、number、bool、array 和 object 五种 JSON 对象。同时实现了 JSON 转 YAML 的功能，用户通过 `json_save` API 将创建的 JSON 对象转换为 YAML 格式。
<!--more-->

lcov 用于检查代码覆盖率的工具

```shell
sudo apt install lcov
```

valgrind 用于检查内存泄露的工具

```shell
sudo apt install valgrind
```

xtest 深信服内部实现的 C 语言单元测试框架

工作成果：https://github.com/hespoon/sangfor-orientation

## 收获

第一次纯粹使用 C 语言编写函数，对 C 的特性有了更多了解。

C 中没有引用只有指针，所以在递归函数中传递一个所有函数都唯一的变量时，需要先在堆中申请内存，然后将指针传递给递归函数。

指针作为参数传递时，属于按值传递，函数会产生一个指针副本，该副本和原指针指向同一个位置，可以通过该副本操作原指针指向的内存。由于 C 中没有引用，所以想在函数中修改原指针的指向时，只能通过指针的指针，而不能使用指针的引用。

C 语言中 case 关键字后的第一行必须是一个表达式，不能是一个声明语句。因此推荐在 case 后加大括号。并且，不加大括号时，同一个 switch 的不同 case 下属于同一个作用域，很容易产生声明冲突。。:scream:

C 语言的字符串操作不方便，strcat、strcmp、strdup、strcpy 很强大，但需要小心使用。

C 语言可以通过在头文件声明结构体，在 .c 文件中实现结构体的方式实现数据封装。C 语言结构体的属性都是 public 的。要实现对结构体的封装，只允许用户通过 API 操作结构体，需要在 .h 文件中声明结构体和 AIP 函数，在 .c 文件中实现结构体和 API 函数。这样，用户无法获取结构体的定义，不知道结构体中具体有哪些属性，只能通过 API 操作结构体。

当在其他文件中 include “.h” 文件时，只能定义 .h 文件中声明的结构体类型的指针，而不能定义结构体类型的变量。因为在定义变量时，编译器需要给变量分配内存空间，而编译器并不知道该结构体的具体结构，自然也无法分配空间，定义结构体的变量会导致编译错误。而定义指针就很简单了，指针就是一个四字节的无符号整数。同时，在这种情况下也无法通过指针访问结构体的字段，强行访问会导致编译错误，因为编译器不知道结构体的实现细节。

通过上述方法很好的实现了数据封装，在 .c 文件之外都只能通过 API 访问结构体，只是需要写很多操作函数，包括为结构体指针变量分配空间的函数。

只在一个文件内使用的函数一般用 static 修饰比较好。

C/C++ 在进行内存分配时要确保内存申请成功了，必须要进行指针的检查。

stderr 是没有缓冲的，要输出的内容会直接显示在控制台中，保证了实时性，因此错误提示的输出一般都是输出到 stderr。

stdout 是有缓冲的，输出的内容有时延。

函数中可以使用断言来建立契约，将一些简单的，调用者可以完成的参数校验交给调用者完成。

makefile 真好用！

**最大的收获**是老师教的编码方式：先写测试用例，再实现函数。通过测试用例检查函数的 bug，通过 lcov 查看函数执行过程中的内部信息，最后通过 valgrind 检查是否存在内存泄露，这一套操作下来函数基本就没问题了。

先写测试用例可以帮助思考函数的实现方式，减少遗漏，有助于一次编码就把函数写正确。在本次开发中，单元测试和 lcov 联合起来基本取代了断点调试，而且操作起来比断点调试要愉快的多，比较符合多动脑少动手的理念。

实现函数时不要贪多，要一个一个的实现，先实现基础函数，在实现复杂的需要调用其他函数的函数。同样，要遵循先设计测试用例，再实现函数的原则。

我是在所有函数都测试通过后才做的 valgrind 内存检查，没有检查到任何的内存泄露，一次通过。