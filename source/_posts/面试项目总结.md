---
title: 面试项目总结
date: 2020-01-13 19:06:42
tags:
---
# 余大佬的面试经验
* 多刷算法题
* 啃《高级 Unix 编程》
* 掌握基本 Linux 知识
* 掌握常见的协议，如 http、tcp 之类的
* 网络安全，如 CSRF、XSS
* 项目经验会问项目设计相关内容
* 研究 LevelDB
* 用 C++ 实现一个 http 服务器
* 熟练使用 epoll 可以保证有话题聊
* 消息队列及常见消息中间件
* 问道不会的直接说不会，不会扣分
* 算法题最难到动态规划
* 每一面都会问算法问题

# 计算机网络
* TCP 协议 Transmission Control Protocol
* TCP 是传输层的协议，解决传输的可靠、有序、无丢失和不重复。
* 面向连接的，每条 TCP 连接只有两个端点
* 全双工通信，通信双发在任何时候都能发送数据，有缓存，用于临时存放双向通信数据
* 面向字节流，TCP 将应用程序交付的数据视为一串无结构的字节流
* TCP 首部最短 20B。
    * 源端口，目的端口各占 2B。
    * 序号字段 4B，每个字节都会编号。
    * 确认字段 4B，是期望收到的报文段数据的第一个字节的序号
    * 数据偏移，4 位。单位是 4B。表示首部的长度
    * 保留字段 6 位
    * 6 个状态位。URG 紧急位、ACK 确认位、PSH 推送位、RST 复位位、SYN 同步位、FIN 终止位
    * 窗口字段。指出现在允许对方发送的数据量，单位为字节。
    * 校验和。 2B，校验首部和数据两部分，计算时要加上伪首部。
    * 紧急字段指针，2B。指出本报文段中紧急数据共有多少字节。
    * 选项字段，长度可变。
    * 填充字段。使头部的长度为 4B 的整数倍。
* 建立连接的 3 次握手
    * SYN=1，seq=x，不含应用层数据，消耗一个序号
    * SYN=1，ACK=1，ack=x+1，seq=y，不含应用层数据，消耗一个序号，服务器为连接分配资源，因此易受 SYN 洪泛攻击
    * ACK=1，seq=x+1，ack=y+1，可以开始携带应用层数据，客户端为连接分配资源
    * 为何要三次握手？为了解决网络中存在延迟的重复分组。比如，客户端发送了一个连接请求，但在网络中长时间的滞留了，以至于延迟到连接结束后的某个时间到达了服务器。服务器会误以为这是一个新的连接请求，然后响应该请求并发出确认，为连接分配资源。如果不采用三次握手，客户端不理睬服务器的确认，不会向服务器传输数据，因此服务器的资源就被浪费了。
* 断开连接的 4 次挥手
    * FIN=1，seq=u，客户端主动请求断开连接
    * ACK=1，seq=v，ack=u+1，此时客户端到服务器的连接已经释放了，TCP 处于半关闭状态，服务器发送数据，客户端依旧要接收。客户端不能发送数据，但可以发送确认报文。
    * FIN=1，ACK=1，seq=w，ack=u+1，此时服务器请求释放连接
    * ACK=1，seq=u+1，ack=w+1，客户端收到服务器发来的连接释放报文后，必须要发出确认，然后等待 2 个报文最大生存时间后关闭连接。服务器端在接受到客户端的确认报文后就断开连接。 
    * 为何要四次挥手？
    因为在客户端主动要求断开连接后，服务器端还可能存在需要发送的数据，要等这些数据发送完后，再断开 TCP 连接。
    * 为何要有 TIME_WAIT 阶段
    因为客户端在发送确认报文后，服务器端可能没有收到，此时服务器会再次发送请求断开连接的报文，客户端应当保持 TCP 连接一段时间，以便保证服务器端收到了自己的确认报文。同时，TCP 连接占用了一个套接字，连接释放后，该套接字会被其他连接重复使用。若没有 TIME_WAIT 状态，网络中可能还存在当前连接产生的报文，连接释放后，旧的报文可能会被新的连接接收，造成信息混乱。因此，TIME_WAIT 状态主要是保证当前连接产生的报文在网络中已经全部消失了。
* TCP 可靠传输
    * TCP 通过校验机制保证传输的报文段没有差错
    * TCP 通过首部的序号字段保证数据能够有序的提交给应用层，对每个字节进行编号，同时会丢弃重复数据。
    * TCP 通过首部的确认号表示期望收到的下一报文段数据的第一个字节的序号，发送方会在缓存中存储那些已经发送但未确认的报文段，以便在需要时重传。使用累计确认
    * TCP 重传。
        * 超时重传。TCP 为每一个发送的报文段都设置一个计时器。计时器设置的重传时间到期但还没有收到确认，就要重传这一报文段。超时重传时间 RTO，加权平均往返时间 RTTs，RTT 的偏差的加权平均值 RTTd。RTO = RTTs + 4 × RTTd，RTTs = ( 1 - α ) × 旧 RTTs + α × 新 RTT 样本，RTTd = ( 1 - β ) × 旧 RTTd + β × |RTTs - 新 RTT 样本|。α 和 β 都是小于 1 大于 0 的系数。第一个 RTTs 等于测量到的 RTT，第一个 RTTd 等于测量到的 RTT 的值的一半。
        * 冗余 ACK
        发送方可以通过冗余 ACK 来检测丢包情况。TCP 规定，每当接收方收到比期望序号大的失序报文段时，就发送一个冗余 ACK，指明下一个期待字节的序号。当发送方收到对同一报文段的三个冗余 ACK 时，就认为该报文段已经丢失。冗余 ACK 也用在了拥塞控制中。
* TCP 流量控制
    * TCP 提供一种基于滑动窗口协议的流量控制机制。
    * 接收方根据自己缓存的大小，动态调整接收窗口的大小，就是调整头部中的窗口字段。限制发送方的发送速率。
    * 发送方根据当前网络的拥塞情况调整拥塞窗口的大小。发送方的发送窗口取接收窗口和拥塞窗口两者中的最小值。
* TCP 拥塞控制
    * 两个窗口，接收窗口和拥塞窗口。发送窗口 = min(接受窗口，拥塞窗口)
    * 四种算法，慢开始、拥塞避免、快重传、快恢复。四种算法是用来维护拥塞窗口的。
        * 慢开始。刚开始发送报文段时，令拥塞窗口 = 1，即一个最长报文段的大小。每收到一个对新报文段的确认后，将拥塞窗口的值加 1，就是增大一个 MSS。一般每经过一个传输轮次，拥塞窗口的大小就会翻倍。慢开始一直把拥塞窗口增加到一个阈值后，就改用拥塞避免算法。
        * 拥塞避免。发送端的拥塞窗口每经过一个 RTT 就增加 1，就是开始线性增加。
        * 网络拥塞处理
            * 超时
            当发送方检测到超时时，就将慢开始阈值设为当前拥塞窗口大小的一半，但不能小于 2，并将拥塞窗口的大小设为一个 MSS。然后开始执行慢开始算法。这样可以快速减少发送方发到网络中的分组数。
        * 快重传
        当发送方连续收到三个冗余 ACK 时，就直接重传接收方未收到的报文段，不用等到超时。
        * 快恢复
        当发送方收到三个冗余 ACK 时，就将慢开始阈值设为当前拥塞窗口的一半，将拥塞窗口设为改变后的慢开始阈值，然后执行拥塞避免算法。
* UDP 协议，User Datagram Protocol
* UDP 的优点
    * UDP 无需建立连接，所以没有建立连接带来的延时，速度比较快。
    * UDP 不用维护连接状态，就是说不用维护发送接收缓存，不用记录确认序号和拥塞控制参数，消耗的资源就小一些。
    * 分组头部开销小，只有 8B。
    * 发送方的应用层能够更好的控制要发送的数据和发送时间。因为 UDP 没有拥塞控制，所以网络中的拥塞不会影响发送方的发送效率。
* UDP 应用
    * 一次性传输数据较少的应用。比如 DNS。
    * 多媒体应用。比如实时视频会议。可靠的数据传输对这些应用来说不是最重要的。
* UDP 不保证可靠交付，数据的可靠性要通过应用层来完成。
* UDP 面向报文，将应用层传下来的报文添加首部后就交给网络层，将网络层传上来的报文去除首部后就交给应用层。
* UDP 数据报首部
    * 2B 的源端口号。需要对方回复时才会使用。
    * 2B 的目的端口号。
    * 2B 的长度标记，单位为 1B
    * 2B 的校验和。是可选的。计算校验和时要在数据报之前添加 12B 的伪首部。校验整个数据报。
* TCP 与 UDP 的区别
    1. TCP 是有连接的，UDP 是无连接的
    2. TCP 是可靠的，UDP 是不可靠的。接收方不会对 UDP 报文发送确认报文。
    3. TCP 是面向字节流的，UDP 是面向报文的。TCP 发送报文时以字节为单位，应用层传来的数据报可拆分。UDP 不能拆分数据报。
    4. TCP 有拥塞控制机制，UDP 没有。
    5. TCP 首部开销大，UDP 首部开销小。
    6. UDP 不需要维护连接状态，消耗资源小。
    7. TCP 只支持点对点通信。UDP 可以一对一、一对多、多对一、多对多
* 如何选择 TCP 与 UDP
对实时性要求高，对可靠传输要求低时，一般选用 UDP。比如 DNS 服务，直播。对可靠性要求高时用 TCP。HTTP 协议一般都用 TCP。HTTP3 使用了基于 UDP 协议的QUIC 协议。可能是因为现在网络环境越来越好了吧，设备本身越来越可靠，协议上就可以偷些懒。
* TCP 粘包
    * 指发送方发送的若干数据包在到达接收方时粘成了一包。从接收方缓存来看，后一包数据的头紧挨着前一包数据的尾。如果粘包是同一数据的不同部分，可以不处理。如果粘包之间没有关系，此时就必须要使用合理的拆包机制将包分开。
    * 粘包原因
        1. 发送方默认使用 Nagle 算法，将多次间隔较小，数据量较小的数据报合并成一个数据量大的数据报发送，用于减少网络中的报文段，尽可能的利用网络带宽。
        2. 接收方读取接收缓存的速度比 TCP 写入缓存的速度慢。
    * 解决方法
        * 发送方可以尝试关闭 Nagle 算法。接收方可以在应用层处理。将接收缓存的数据全部读完后，再分组。可以通过开始符和结束符的方式分组，也可以在数据报数据部分的开始部分记录数据的长度。
* HTTP HyperText Transfer Protocol
    * HTTP 由两个程序实现，一个客户端程序，一个服务器程序。
    * URL 地址包含两部分，存放文件的服务器地址和文件的存放路径
    * HTTP 使用 TCP 作为传输协议，应用通过套接字接口将 HTTP 请求发给 TCP 连接，同时也从套接字接口中接受响应信息。
    * 持续连接。客户端与服务器在一个相当长的时间范围内通信时，所有的请求和相应都通过一个 TCP 连接发送，这种模式称为持续连接。
    * 非持续连接。客户端与服务器在一个相当长的时间范围内通信时，每个请求和相应都通过一个单独的 TCP 连接发送。
    * HTTP 默认使用持续连接，也可以使用非持续连接。
    * HTTP 客户端进程运行在 80 号端口。
    * 非持续连接中的 TCP 连接可以是串行的也可以是并行的。
    * HTTP 有两种报文，请求报文和相应报文。HTTP 的报文是明文传输。是无状态的，服务器不会记录客户端的任何信息。
        * 请求报文
            * 请求报文的第一行叫做请求行，后续的行叫做首部行。
            * 请求行包含三个字段。方法字段、URL 字段和 HTTP 版本字段。
            * 首部行 Host 指明了对象所在的主机
            * 首部行 Connection 指明了是使用持续连接还是非持续连接
            * 首部行 User-agent 指明了用户代理，即向服务器发送请求的浏览器的类型
            * 首部行后有一个空行。空行后是请求的实体。
            * GET 方法用与获取服务器内容，向服务器传递的参数加在 URL 中，只允许 ASCII 字符，有长度限制。请求的实体为空。
            * GET 方法是幂等的。幂等是指，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。
            * POST 方法一般用来向指定的资源提交数据进行处理请求，如上传表单和文件。数据包含在请求体中。
            * POST 方法是不幂等的。
            * HEAD 方法用于向服务器索要与 GET 请求相一致的响应，但是响应体不返回，只返回响应消息的头部。
            * PUT 方法用于向指定资源位置上传其最新内容，是幂等的。
            * DELETE 方法用于删除 URL 所标识的资源。
        * 响应报文
            * 第一行是状态行。包含 HTTP 版本，状态码和状态描述
            * 接下来每一行都表示一个 HTTP 首部，为客户端提供关于所发送数据的一些信息，并以一个空行结束
            * 最后是数据块，包含了响应数据
            * 200 OK 表示请求成功
            * 302 Found 临时重定向
            * 404 Not Found 请求失败，所请求的资源未在服务器上找到
    * HTTP 常见状态码
    1. 1xx 状态码 信息，服务器收到请求，需要请求者继续执行操作。100 Continue 继续、101 Switching Protocols 切换协议，只能切换到更高级的协议
    2. 2xx 状态码 操作成功。200 OK 请求成功
    3. 3xx 状态码 重定向。301 Moved Permanently 永久重定向、302 Found 临时移动
    4. 4xx 状态码 客户端错误。400 Bad Request 客户端请求语法错误、401 Unanuthorized 请求用户的身份认证、403 Forbidden 服务器拒绝执行、404 Not Found 服务器未找到客户端请求的资源
    5. 5xx 状态码 服务端错误。500 Internal Server Error 服务器内部错误、501 Not Implemented 服务器不支持请求的功能、502 Bad GateWay 网关或代理服务器执行请求时，从远程服务器接收到了一个无效响应。
    * HTTP 重定向
    URL 重定向，也称 URL 转发，是一种当前实际资源，如页面，表单等迁移到新的 URL 下的时候，保持原有链接可用的技术。HTTP 使用 HTTP 重定向来执行此类操作。可以用于网站维护期间的临时跳转或者网站架构改变后为保持外部链接继续可用的永久重定向。
    重定向操作由服务器发送特殊的响应而触发，状态码是 3xx。浏览器接受到重定向响应后，会采用响应提供的新的 URL，并立即加载。
    永久重定向：表示原 URL 不再使用，应优先选用新的 URL。
    临时重定向：资源无法从其标准的地址访问，却可以从另外的地方访问。搜索引擎不会记录这个新的、临时的链接。临时重定向也可以用来显示临时性质的进度页面。
    特殊重定向：304 Not Modified 资源未修改，会使页面跳转到本地缓存的版本中。300 Multiple Choice 是一种手工重定向，以 Web 页面的形式呈现消息主题包含的一个可能的重定向链接列表，用户可以从中选择。
    * HTTPS
        * 运行在 SSL （Secure Sockets Layer 安全套接层 位于传输层和应用层之间）上，添加了加密和认证机制，更加安全。
        * 通信需要证书，一般是向证书颁发机构购买。证书就是一个公钥和一个私钥。
        * 首先建立 TCP 连接。然后客户端向服务器发送客户端支持的一套加密规则
        * 服务器从中选取出一组加密算法与 Hash 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里包含了网站地址，加密公钥，和证书的颁发机构等信息。
        * 客户端验证服务器的合法性
        * 如果证书受信任，或者客户端接受了不受信任的证书，浏览器会生成一个随机密钥，并用服务器提供的公钥加密。使用 Hash 算法对握手消息进行摘要计算，并对摘要使用之前产生的随机密钥加密。然后，将加密后的随机密钥和摘要发给服务器。
        * 服务器用自己的私钥解开被加密的随机密钥，并用随机密钥解出被加密的 Hash 摘要，验证握手信息是否一致。如果一致，则服务器使用获得的随机密钥加密握手消息发给客户端。
        * 客户端解密并验证摘要，若一致，则握手结束，以后发送的数据都使用该随机密钥进行对称加密。
        * 证书公钥用于加密在握手过程中生成的随机密钥，随机密钥用于加密真正传输的数据，Hash 算法用于验证数据的完整性。
        * 对称加密，加密和解密使用同一个的密钥。
        * 非对称加密，需要两个密钥，公钥和私钥。使用公钥加密的内容用私钥才能解开。
    * HTTPS 中间人攻击及防范
        * 中间人攻击 MITM（Man-in-the-middle attack）
        中间人攻击是指攻击者与通讯的两端分别建立独立的连接，并交换其收到的数据，使通讯的两端认为他们正在通过一个私密的连接直接与对方通讯，但事实上整个会话都被攻击者控制。攻击者可以拦截通讯双方的通话并插入新的内容。
        * 客户端请求与服务器发起 HTTPS 通信，信息被中间人获取。服务器把自己的公钥发给客户端，信息被中间人获取，中间人将公钥改为自己的公钥，再发给客户端。客户端收到公钥，生成随机密钥并用公钥加密随机密钥发给服务器，信息被中间人获取，中间人用自己的私钥解密获得随机密钥。现在中间人有服务器的公钥和客户端产生的随机密钥。中间人将随机密钥用服务器的公钥加密，再发给服务器。服务器用自己的私钥解密，获得随机密钥。以后客户端与服务器的通信都通过随机密钥进行，而中间人有该随机密钥，所以中间人可以获得所有的通信信息。
        * 防范中间人攻击，就是要保证通信中的信息来自正确的发送者，且没被修改过。保证客户端收到的信息来自服务器，保证服务器收到的信息来自客户端，保证中间没有一个家伙能查看并修改信息。
        * 可以通过数字签名来保证某段信息确实来自它所声称的那个实体。比如，服务器在产生要发送的消息后，通过 Hash 算法计算摘要，然后用自己的私钥加密摘要，生成数字签名。消息接受者收到信息和数字签名后，使用同样的 Hash 算法计算信息摘要，使用公钥解密数字签名获得服务器端发来的摘要。比对两个摘要查看是否一致。如果一致，可以保证信息来自对方且没被修改过。但是这种方式依旧可以被中间人攻击，中间人可以在会话建立阶段将双方交换公钥换为自己的公钥，获取双方计算信息摘要的 Hash 算法。这样中间人依旧可以修改信息而不被发现。
        * 为了解决这个问题，通信双方需要找一个双方都信任的第三方来为双方确认身份。就是向数字证书机构购买数字证书。
        * 数字证书就是将购买人的一些必要信息，比如公钥、姓名、电子邮件、有效期等提供给 CA，CA 验证消息后，用自己的私钥加密这些信息，形成数字签名，并附在证书最后，再将数字证书颁发给购买者。这样，购买者就可以通过数字证书向别人证明他自己的身份了。对方收到数字证书后，在通过 CA 的公钥解密证书最后的数字签名，得到发送方的信息，再与发送方发来的信息比对，如果两者一致，则说明发送方是正确的，信息没有被中间人修改过。
        * 公钥开始时由服务器端提供，此时很容易被中间人换掉，因此需要数字证书来保证公钥的正确性。
        * 数字证书上的数字签名使用 CA 的私钥加密的，客户端解密时是用 CA 的公钥解密的。因此安全性由 CA 来确保。
        * CA 证书是分等级的，次一级的 CA 证书由上一级的 CA 证书来确保自身的正确性，CA 证书的顶级是根证书。根证书不通过网络分发，而通过操作系统或浏览器分发。操作系统会内置很多根证书。
        * 硬件厂商会和证书签发机构合作，在硬件中内置签发机构的根证书。此时的安全性依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证。
    * 如何由 www.example.com 跳转至 https://www.example.com 
    如果网站启用了 HTTPS，则服务器会将这个请求使用 301 永久重定向或者 302 临时重定向将请求从 HTTP 的 80 端口重定向到 HTTPS 的 443 端口。
    此时，如果中间人劫持了使用者的网络请求，那么中间人可以阻止客户端与服务器建立 HTTPS 连接，而一直使用 HTTP 连接，而中间人则和服务器建立正常的 HTTPS 连接，让客户端以为自己在和真正的服务器通信，这种攻击手法称为 SSLTrip。
* Session 与 Cooike 的区别
Session 是服务器保持状态的方法，Cooike 是客户端保持状态的方法。
Cooike 是本地机器存储的一个小段文本，并随着每一个请求发送至同一个服务器。服务器通过 HTTP 头向客户端发送 Cooike。在客户端，浏览器解析这些 Cooike 并把它们保存为一个本地文件，浏览器会自动的将向同一服务器发送的任何请求上附加这些 Cooike。
Cooike 是用户端的会话状态保存机制。Cooike 的作用是为了解决 HTTP 协议无状态的缺陷。
Cooike 的主要内容包含：名字、值、过期时间、路径和域。路径和域一起组成 Cooike 的作用范围。如果不设置过期时间，则表示 Cooike 的生命周期为浏览器的会话期间，关闭浏览器，Cooike 就消失，这种 Cooike 被称为会话 Cooike，一般存放在内存中。若设置了过期时间，浏览器就会把 Cooike 保存到硬盘上，关闭后再次打开浏览器，这些 Cooike 依旧有效直到超过设定的过期时间。
Session 机制采用的是在服务器端保持状态的解决方案。由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以 Session 机制可能需要借助 Cooike 机制来达到保存状态的目的。
Session 是针对每一个用户的，Session 的值保存在服务器端，使用 SessionID 来区分用户。SessionID 是一个不容易被找到规律的字符串，用来防止仿造。
服务器接受到客户端的请求时，会检查请求中是否包含一个 SessionID，如果包含，则服务器会通过 SessionID 检索 Session，如果检索不到则会新建一个。如果客户端请求中不包含 SessionID，则服务器为次客户端创建一个 Session 并生成一个与该 Session 关联的 SessionID，SessionID 会在本次响应中返回给客户端。
保存这个 SessionID 的方式可以使用 Cooike。当客户端禁止使用 Cooike 时，可以采用 URL 重写的技术，把 SessionID 直接附加在 URL 的路径后，类似于 URL 的参数。还有一种技术称为表单隐藏字段，服务器自动修改表单，增加一个隐藏字段，以便表单在提交时能够把 SessionID 传递给服务器。
Cooike 中只能保存 ASCII 字符串，如果需要存放 Unicode 字符或者二进制数据，则需要先进行编码。因此存储较复杂的状态，使用 Cooike 是比较困难的。
Session 中能存放任何类型的数据，使用起来比较方便。
Cooike 中的信息存放在客户端，因此最好不要存放一些敏感信息，比如帐号密码，因为一些客户端的不良程序可能会窥探甚至修改 Cooike 中的内容。也可以对 Cooike 加密，提交到服务器后再解密。
Session 在服务器端，保存隐私信息很方便。
Cooike 可以设置一个长时间的有效期，来保持状态一直有效，比如保持登陆。
Session 一般依赖一个会话 Cooike，浏览器关闭后，该 Session 就失效了。而且 Session 一般不应维持较长的有效期，因为这样会对服务器带来较大的压力。并且，Session 不适用于访问量超高的网站，因为这种网站使用 Session 保存状态的话，会消耗大量服务器资源。
Cooike 存放在客户端，如果网站的并发量超大，一般都采用 Cooike 保存状态。 
Cooike 的有效时间，有效位置容易设置，Session 就不行。
Cooike 支持跨域名访问。Session 不支持跨域名访问。
* session 的实现
  session 由三个组件配合完成，分别为 `Manager`、`Provider` 和 `Session` 这三个类。

  下图是一个 HTTP 请求的完整流程

  ![http的请求过程.jpg](http://ww1.sinaimg.cn/large/006XJF4Oly1gbq9oo19c7j30u00gwgn8.jpg)

  1. Handler 函数用于接收请求，解析 HTTP header  中的 cooike，得到 SessionID，然后把 SessionID 发给 Manager。
  2. Manager 充当一个 Session 管理器的角色，主要用于存储配置信息。比如：session 的存活时间，Cooike 的名字等。Manager 将 SessionID 接着发给 Provider。
  3. Provider 是一个容器，一般是一个散列表，将每个 SessionID 和 Session 的对应关系存储起来。
  4. Session 中存放用户的具体信息，一般是一个散列表。

* Cross-Origin Resource Sharing（CORS）跨域资源共享
一般是指，一个域下的文档或脚本试图请求另一个域下的资源。
* 从输入 URL 到获得页面的过程
    * 浏览器查询 DNS。浏览器自己的 DNS 缓存，本地 Host 文件，操作系统的 DNS 缓存，本地 DNS 服务器，递归查询或迭代查询
    * 浏览器获得 IP 地址后，向服务器建立 TCP 连接。
    * TCP 连接建立后，浏览器向服务器发送 HTTP 请求。
    * 服务器响应 HTTP 请求。
    * 浏览器不断请求资源，最终渲染出整个页面。
* 网络层
* 功能：互联异构网络、路由与转发、拥塞控制
    * 异构网络：好多个网络，各个网络由不同厂家生产的计算机组成，使用了不同的协议。
    * 路由与转发：通过路由器实现
    * 拥塞控制：ICMP Internet Control Message Protocol 网络信息控制协议
* 路由算法
    * 静态：网络管理员手工配置
    * 动态：通过路由器间彼此交换信息来构造路由表，分为距离-向量算法和链路状态算法。
        * 距离-向量算法
        所有的路由器都定期地将它们自己的整个路由选择表传送给所有与之相连的临近路由器。路由选择表包含每条路径的目的地和路径的代价。
        * 链路状态算法
        每个参与该算法的节点都有整个网络的拓扑信息。一个结点检查所有与之直连的链路的状态，并将所得的信息发送给网络上的所有其他节点。其他结点包括和它直连的和不直连的。当一个结点收到其他节点发来的链路状态时，该节点就通过这些信息更新自己维护的整张网络的拓扑图。如果链路状态发生变化，就通过 Dijsktra 算法计算最短路由。只有链路状态发生变化时，结点才会发送此消息。消息传递使用的是洪泛法。
* 层次路由
将互联网分为许多较小的自治系统，系统有权决定自己内部使用什么路由协议
    * 内部网关协议 
    自制系统内部使用的协议。比如使用距离向量算法更新路由表的 RIP 协议和使用链路状态算法更新路由表的 OSPF 协议。
    * 外部网关协议
    自制系统之间的网关协议。比如 BGP4。
* IPV4
* 首部，固定部分为 20B，还有一部分的变长部分。
* NAT Network Address Transform 网络地址转换
用于实现专用网络与公共网络之间的地址转换
* 子网划分
使用子网掩码，对物理子网再一次进行划分。IP 地址分为三部分：网络号，子网号，主机号
* CIDR Classless Inter-Domin Routing 无分类域间路由选择
用于消除传统的 A、B、C类网络划分。IP 地址分为两部分：网络前缀和主机号。需要在 IP 地址后用斜线记录网络前缀占用的比特数。可以合并路由表的表项。
* 路由聚合
将网络前缀相同的连续 IP 地址组成 CIDR 地址块。使得一个地址块可以表示多个地址，减少路由表的表项，从而降低路由器间交换信息的大小
* ARP address resolution protocol 地址解析协议
对于特定的 IP 地址，查询其对应的物理地址
* DHCP dynamic host configuration protocol 动态地址配置协议
给网络中的主机动态分配 IP 地址
* ICMP internet control message protocol 网络控制信息协议
用来给主机和路由器报告差错和异常，用于拥塞控制。
* IPV6 
首部固定 40B，地址长度 16B，用于解决 IPV4 地址耗尽的问题
* 路由协议
    * 自制系统内
        * RIP 协议 Routing Information Protocol
        基于距离向量算法的路由选择协议。
        网络中的每个路由器都要维护从它自身到其他每一个目的网络的距离记录。
        距离用跳数表示，路由器与网络直连时跳数为 1。每经过一个路由器，跳数加一。16 跳时，表示网络不可达。
        RIP 认为跳数少，则该路径就好。
        仅与相邻的路由器交换信息。交换的是整个路由表。每个固定的时间，就交换一次信息。
        应用层协议，使用 UDP 传输数据
        * OSPF 协议 Open Shortest Path First 开放最短路径优先协议
        基于链路状态算法的路由选择协议。
        使用洪泛法发送信息。
        只发送与本路由器直连的链路的状态。
        只有链路状态发生变化时，才发送信息。
        网络层协议，直接使用 IP 数据报发送信息，此时 IP 数据报首部的协议字段为 89。
        每个链路状态都附带一个 32 位的序号，序号越大，状态越新。
    * 自制系统间
        * BGP border gateway protocol 边界网关协议
        只力求找到一条能够到达目的网络且比较好的路由，而不是寻找最佳路由。
        主要用于处理各 ISP 之间的路由选择。
        应用层协议，使用 TCP 传输数据。
* IP 组播
一个发送者与多个接受者之间实现一对多的数据传输。使用 UDP 协议传输数据，IP 地址为 D 类地址。

* 计算机网络体系结构
    * 原理的体系结构：应用层、传输层、网络层、数据链路层、物理层
    * IOS 7 层结构：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
    * TCP\IP 4 层结构：应用层、传输层、网际层、网络接口层
* 应用层常见协议
    * FTP 文件传输协议 使用 TCP 21端口为控制端口，20端口是数据连接端口
    * HTTP 超文本传输协议 80端口 
    * HTTPS 加密的超文本传输协议 443 端口
    * DNS 地址解析协议 53端口 使用 UDP
    * STMP 发送邮件协议 客户端向邮件服务器发邮件，邮件服务器向邮件服务器发邮件 25端口 使用 TCP
    * POP3 接收邮件协议 邮件服务器向客户端发邮件 110端口 使用 TCP
    * TELNET 远程登录 23端口


# 操作系统基础
## 进程与线程的区别
* 进程是系统进行资源分配和调度的基本单位，线程是 CUP 调度和分派的基本单位
* 线程依赖于进程
* 进程有自己的独立地址空间，同一进程的不同线程共享当前线程的地址空间
* 线程基本上不拥有系统资源，只有一点在运行中必不可少的资源，比如自己的线程 ID、程序计数器、一组寄存器和栈。同一进程的不同线程共享该进程的系统资源，比内存，CUP，I/O 等。
* 进程切换时开销大。因为操作系统要分配和回收资源。同一进程内的线程切换时开销小。
* 线程间通信比较方便，因为同一进程下的线程共享全局变量等数据。进程间通信比较复杂，要通过 管道、信号量等方式。
* 线程有两种实现方式：用户级线程和内核级线程。
* 用户级线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。
* 内核级线程，线程管理的所有工作由内核完成，应用程序没有线程管理的代码，只有一个到内核级线程的编程接口。
* 多线程模型：多对一模型、一对一模型、多对多模型
* 多对一模型：将多个用户级线程映射到一个内核级线程上，线程管理在用户空间完成。一个线程阻塞时，整个进程都阻塞。
* 一对一模型：每个用户级线程都对应一个内核级线程。并发能力强。
* 多对多模型：m 个用户级线程映射到 n 个内核级线程上，要求 n ≤ m
## 进程间通信
* 共享存储
通信进程间共享一块可以直接访问的内存空间。通过对这块共享空间的读写操作来实现进程间的信息交换。对共享空间的读写需要用到 P、V 操作实现同步互斥。
* 消息传递
进程间的数据交换以格式化的消息为单位。进程间通过操作系统提供的发送消息和接受消息两个原语进行数据交换。
直接通信方式：发送进程直接把消息发给接收进程，并把消息挂在接收进程的消息缓冲队列上。
间接通信方式：发送进程把消息发到某个中间实体，接收进程从中间实体获得消息。
* 管道通信
管道是连接一个读进程和一个写进程以实现他们之间通信的一个共享文件。写进程向管道写入数据，读进程从管道读出数据。数据被读出后就会被抛弃。管道是半双工通的，要向实现双向通信，则需要两个管道。
## 进程间调度策略
* 先来先服务
* 最短作业优先
* 优先级调度算法
    * 优先级反转问题
    高优先级的进程等待被一个低优先级进程占用的资源时会出现优先级反转。
    * 解决方法
    优先级继承：将低优先级进程的优先级提升到等待它所占有的资源的最高优先级进程的优先级。当高优先级进程由于等待资源而被阻塞时，此时资源的拥有者的优先级将会自动被提升。
    优先级天花板：将申请某资源的进程的优先级提升到可能访问该资源的所有进程中最高优先级进程的优先级.(这个优先级称为该资源的优先级天花板) 
* 高响应比优先调度算法
* 时间片轮转
* 多级反馈队列
## 进程间同步
* 多道程序环境下，进程是并发执行的，但不同进程之前存在这制约关系，为了协调进程间的制约关系，引入了进程间同步。
* 临界资源：一次仅允许一个进程使用的资源称为临界资源
* 临界区：进程中访问临界资源的那段代码
* 同步：为完成某种任务而建立的两个或多个进程，这些进程间因为需要在某些位置上协调他们工作次序而产生制约关系。
* 互斥：当进程进入临界区使用临界资源时，另一个进程必须等待。
* 同步机制的四个准则：空闲让进、忙则等待、有限等待、让权等待
* 信号量机制：信号量机制使用两个原语 “P 操作” 和 “V 操作” 解决同步互斥问题。整型信号量和记录型信号量。
* 管程：管程是由一组数据及定义在这组数据上的对这组数据的操作所组成的软件模块。
* 管程的组成
    1. 局部于管程的共享数据结构，该组数据结构可以用于描述系统中的各种软件资源和硬件资源
    2. 对该数据结构进行操作的一组方法
    3. 对该数据结构设置初始值的语句
* 管程的特性
    1. 管程内的共享数据只能通过管程的方法操作
    2. 每次只允许一个进程在管程内执行某个管程的方法
## 死锁
* 死锁的必要条件
    * 互斥：在某一段时间内，一个资源只能由一个进程占有。若此时有其他进程申请资源，则发起请求的进程只能等待。
    * 不剥夺：进程获得资源在未使用完之前，不能被其他进程强行夺走。资源只能由获得资源的进程主动释放。
    * 请求并保持：进程已经获得了至少一个资源，同时又提出了新的资源请求，而该资源已被其他进程占有，此时请求资源的进程被阻塞，但不释放自己获得资源。
    * 循环等待：存在一种进程资源的循环等待链，链中每个进程已获得资源并且该资源同时被链中的下一个进程请求。
* 死锁与循环等待的区别
死锁形成的循环等待环，进程 i 请求的资源必须由进程 i+1 提供。而循环等待链却没有该要求。即进程 i 的请求可以被链外的某个进程持有，该进程释放资源后，循环等待链就会被打破。
* 死锁处理
    * 死锁预防
    破坏死锁的四个必要条件，就可以保证死锁不会发生。
    * 死锁避免
    通过银行家算法实现，保证系统一直处于安全状态
    * 死锁检测和解除
    系统分配资源时，不采取任何措施。用资源分配图检测当前系统状态是否是死锁状态。资源分配图可以完全简化，则说明当前系统未死锁。死锁时，用死锁解除方法解除死锁。比如，撤销一个进程，剥夺某个进程的资源，或者让进程回退到系统不死锁的状态。
## 内存管理
为了更好的支持多道程序的并发，提升系统性能。
* 逻辑地址空间
是指一个源程序在编译或者链接装配后，指令和数据使用的虚拟地址组成的空间。
* 物理地址空间
指内存中真实的物理单元的集合
* 内存保护
通过上、下限地址寄存器。访问内存时，现将地址与上下限寄存器中的地址比较，防止越界。
通过界址寄存器。虚拟地址与必须小于界址寄存器中的值。
* 内存管理方式
    * 连续分配
    一个作业装入一块连续的内存中，内存不够，作业不能执行。
    单一连续分配：内存中只有一个作业，用于单道程序机器。
    固定分区分配：先在内存中划分好若干固定大小的内存区域，每个区域中装入一个作业。可以实现多道程序的并发。
    动态分区分配：不事先划分好内存区域。在进程装入内存时，根据进程的大小动态划分分区。
        * 动态分区分配方法
        按照程序的需要进行动态的划分。分配算法有首次适应算法、最佳适应算法、最坏适应算法和临近适应算法
    * 非连续分配
    允许一个程序分散的装入不连续的内存中。此时，需要额外的空间去存储分散的内存区域的索引。根据分区大小是否固定，分为分页存储管理方式和分段存储管理方式。其中，分页管理方式根据运行作业时，是否需要把作业的所有页面都装入内存，分为基本分页管理和请求分页管理，两种管理方式。
    基本分页：内存分为固定的块，按物理结构划分，会有内部碎片。进程的虚拟内存空间划分为大小相等页，物理内存空间划分为大小相等的页框，一个页刚好装入一个页框中。虚拟地址分为两部分：页号和页内地址。页表记录了页面对应的物理页框号。
    基本分段：内存块的大小不固定，按照逻辑结构划分，会有外部碎片。虚拟地址分为两部分：段号和段内地址。
    段页式：基本分段和基本分页的结合，会有内部碎片。虚拟地址分为三部分：段号、页号和页内偏移。
* 虚拟内存
虚拟内存基于局部性原理，在程序装入时，将程序的一部分装入内存，其余部分留在外面，就可以启动程序执行。在执行的过程中，当所访问的信息不在内存中时，由操作系统将所需要的部分调入内存，然后继续执行。此时，操作系统好像为用户程序提供了一个比实际内存打的多的存储器，称为虚拟存储器。虚拟存储器的大小由计算机的地址结构决定，并不是内存和外存的简单相加。
* 虚拟内存的实现方式
1. 请求分页式存储管理
    * 页表项结构
    与普通页式管理相比，请求分页式管理要处理缺页的情况。如何发现和处理缺页是请求分页管理系统必须解决的问题。因此，页表中增加了四个字段。页表项共有 6 个字段。
    页号、页框号、状态位、访问字段、修改位、外存地址
    状态位用于指示内存中的该页是否有效。
    访问字段用于记录本页在一段时间内被访问的次数，或记录本页最近已经有多长时间未被访问。用于置换算法换出页面时的参考。
    修改位用于标识该页在写入内存后是否被修改过。
    外存地址，是该页在外存上的物理地址。
    * 地址变换 虚拟地址转换为物理地址
    虚拟地址结构：页号和页内地址
    首先访问 TLB，TLB 未命中则访问页表，再未命中则缺页。
    * 缺页中断
    缺页中断属于内中断。
    * 页面置换算法
    1. 理想的最佳置换算法
    2. 先进先出置换算法
    3. 最近最久未使用置换算法
    4. 时钟置换算法又称为最近未使用算法
    先换出未被访问且未被修改的，然后是未被访问但修改了的，然后是被访问但未被修改的，最后是被访问也被修改的
2. 请求分段式内存管理
3. 请求段页式内存管理
* 实现虚拟内存所需要的硬件支持
1. 一定容量的内存和外存
2. 页表机制或段表机制
3. 中断机构
4. 地址变换机构。实现虚拟地址到物理地址的转换
## 文件系统
* 文件目录
UNIX 的文件目录由文件名和指向文件对应的 inode 的指针组成。
* inode
1. 存放了文件控制文件所需要的各种基本信息。
    1. 文件基本信息
    文件名、文件物理位置、文件的逻辑结构、文件的物理结构
    2. 存取控制信息
    文件存取权限
    3. 使用信息
    文件建立时间、修改时间等
2. 还有文件用到的物理块的地址。
* 文件的逻辑结构
    1. 流式文件。没有结构，将数据按顺序组织成记录并保存，以字节为单位。
    2. 有结构文件。顺序文件、索引文件、索引顺序文件、散列文件
* 文件共享
基于索引节点的硬连接，利用符号链实现的软连接
* 文件控制访问
为每个文件和目录设置一个访问控制表
* 文件描述符、文件描述符表、打开文件表、目录项、inode 结点
每个进程在 PCB 中都有一个数组，名叫文件描述符表，文件描述符就是这个数组的下标。文件描述符 0 表示标准输入流文件，文件描述符 1 表示标准输出流文件，文件描述符 2 表示标准错误输出流文件。文件描述符的表项是一个指向系统打开文件表的指针。
* 系统打开文件表
又叫做系统级的描述符表，表格中的各项条目称为打开文件句柄，是一个 file 对象。一个打开文件句柄存储了与一个打开文件相关的全部信息。如下所示：
    1. 当前文件偏移量
    2. 打开文件时所使用的状态标识
    3. 文件访问模式
    4. 指向该文件 inode 的指针
    5. 文件类型和访问权限
    6. 一个指向该文件持有的锁列表的指针
    7. 文件的各种属性，包括文件大小以及不同类型操作相关的时间戳
    8. 该文件的引用计数，就是指向该表项的文件描述符的个数。关闭一个文件描述符会减少相应的文件的引用计数，当引用计数为零时，内核会删除该文件在系统打开文件表中的表项。
    9. 一个指向 file_operations 结构体的指针，结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如：read、write、open 等函数。
    10. 一个指向 dentry 结构体的指针。“dentry” 是 directory entry 的缩写。open、stat 等函数的参数是文件路径，这些函数需要通过文件路径找到文件的 inode。为了减少磁盘访问，内核缓存了目录的树状结构，称为 dentry cache。该树状结构的每一个结点就是一个 dentry 结构体。open、stat 等函数可以沿着路径各部分的 dentry 结构体搜索即可。dentry 结构体中有一个指向 inode 结构体的指针。inode 结构体保存着从磁盘上 inode 读出来的信息。如果两个 dentry 结构体指向同一个 inode 结构体，则说明这两个文件是硬连接。
系统只维护一个系统打开文件表，所有进程共享这张表。
* 虚拟文件系统
Linux 系统中存在很多物理的文件系统，比如 ext2、ext3、ext4 等。每个文件系统都有自己的文件组织方法，操作方法。Linux 系统通过虚拟文件系统使用户能够透明的处理文件，忽视不同物理文件系统之间的差异。
虚拟文件系统中有四个重要对象：超级块（super block)、索引节点（inode）、目录项（dentry）和文件对象（file）
* 超级块（super block）
一个超级块对应一个真实的物理文件系统，保存文件系统的类型、大小、状态等元信息。不同的物理文件系统对应不同的 super_block，因此对于不同的 super_block 的操作也不同。super_block 结构体中有一个指向 super_operations 结构体的指针，指向某个特定的具体文件系统用于管理这个文件系统中 inode 的操作函数的集合。
内核中的结构处理都是有讲究的，内核单独使用一个简单的结构体将所有 super_block 都连接起来，但这个结构体不是 super_block 本身，因为 super_block 本身太大了，效率不高。
struct file_system_type *s_type 属性：文件系统类型，也就是当前文件系统是属于哪个类型，ext2 还是 ext3。
* 索引节点 inode
保存的是文件的元数据，就是文件属性的描述。例如：文件大小、设备标识符、用户标识符、文件模式、文件读取或修改的时间戳、指向存储文件数据的磁盘区块的指针。
inode 有两种，一种是虚拟文件系统的 inode，一种是具体文件系统的 inode。前者存在与内存中，后者存在于磁盘中。使用 inode 时，要将磁盘上的 inode 填充到内存中的 inode 中。
每个 inode 结点的大小，一般是 128B 或者 256B。inode 结点的总数在磁盘格式化时就给定。一般每 2KB 的硬盘就设置一个 inode。
inode number 是唯一的，表示不同的文件。文件名是给用户使用的，Linux 的系统文件目录的一个表项就是 “文件名 + inode number”。系统通过文件名，找到文件对应的 inode number，再通过 inode number 找到 inode 信息，最后通过 inode 中的指向磁盘块的指针，找到文件的数据。
创建一个文件时，内核就给该文件分配一个 inode，一个 inode 只对应一个实际文件，一个文件也只有一个 inode。inode 的个数就是系统中文件的最大个数。
* 目录项（dentry）
目录项是描述文件的逻辑属性，只存在与内存中，没有实际对应的磁盘描述，是存在于内存的目录项缓存，为了提高查找性能而设计的。所有目录项在一起构成一颗庞大的目录树。
一个目录项对应一个 inode 结构，一个 inode 结构可以对应多个 dentry 结构。
* 文件对象（file）
文件对象描述的是进程已经打开的文件。file 对象组成系统打开文件表。

# 数据库
## 事务的概念与特性
* 事务是一个操作序列，是不可分割的工作单位。
* 特性
1. 原子性，逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
2. 一致性，事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
3. 隔离性，一个事务所做的修改在最终提交之前，对其他事务是不可见的。并发的事务之间不能互相影响。
4. 持久性，事务一旦提交成功，对数据的修改是永久性的。





# C++ 语言细节
## const 关键字
* const 修饰普通变量
```C++
const int a = 7;
```
a 为常量，只能在声明时赋值，不可再次赋值。指向常量的指针和引用，必须被 const 修饰，这样用于防止通过指针或引用修改该常量。
* 指向常量的指针
```C++
const int *p = 8;
int const *p = 8;
```
const 位于 * 的左边，不能通过指针修改指针指向的值。指向常量的指针，可以指向常量也可以指向普通类型。关键是不能通过指针修改指针指向的值。
* 常指针
```C++
int * const p = 8;
```
const 位于 * 的右边，指针是一个指针常量，指针指向的内存地址不能改变，但可以通过指针修改指针指向的值。
* 指向常量的常指针
```C++
int const * const p = 8;
```
const 在 * 的两边都有，指针指向的内存地址不能改变，地址中的值不能通过指针改变。
常指针和指针常量的合并。
* const 修饰函数参数
```C++
// 传值参数
void f(const int a){
    a++; // 错误，不能在函数中修改 a 的值
}
void f(int const *a){
    *a=10; // 错误，不能通过指针修改 a 的值
}
void f(int * const a){
    *a=10; // 正确
    int b=10;
    a=&b; // 错误，不可以改变指针指向的内存地址
}
```
当函数参数是一个自定义的对象时，按值传参时会构建临时对象复制参数，一般采用传引用，为了防止参数在函数体内被修改，常用 const 修饰参数。
* const 修饰函数返回值
1. const 修饰基本数据类型，修饰与不修饰作用相同。
2. const 修饰自定义类型。此时返回一个常量，返回值不能做左值。返回值既不能被赋值，也不能被修改。
3. const 修饰返回的指针或引用。
* const 修饰类的成员函数 const 加在 () 后面
const 修饰成员函数，是为了防止成员函数修改调用这个函数的对象的值。一个类中，任何不会修改数据成员的函数都应该声明为 const 类型。const 修饰的成员函数称为常成员函数，常成员函数不能调用非常成员函数，用来防止常成员函数修改类的属性。只有常成员函数能够操作常对象，没有 const 修饰的的成员函数不能用来操作常对象。如果对象的某个属性希望被自己的 const 成员函数修改，则可以用 mutable 修饰该属性。
* const 修饰引用
const 引用是指向 const 对象的引用。同时，普通的引用是无法绑定到 const 对象上的。为了防止通过普通的引用修改 const 对象。
## static 关键字
* 静态成员变量
类内成员变量声明前加上关键字 static，该数据成员就是类内的静态数据成员。
* 静态成员变量的特点
1. 静态成员变量是该类所有对象共有的。静态成员变量只分配一次内存，由该类的所有对象共享访问。
2. 静态数据成员在全局数据区分配内存，不属于特定的对象，不占用对象的内存。在没有类的实例存在前，静态成员变量就已经存在了。
3. 静态成员变量在初始化时分配内存。静态变量必须初始化，并且只能在类体外进行。初始化时可以赋初值，也可以不赋初值。如果不赋初值，则会被默认初始化。静态数据区的变量都有默认的初始值，动态数据区的变量默认是垃圾值。
4. static 成员变量与普通 static 变量相同，编译时在静态数据区分配内存，到程序结束时才释放。
5. 静态数据成员初始化时可以不加 static，但必须要有数据类型。
6. 静态数据成员可以通过 <类名>::<静态数据成员名> 访问，不需要通过类的对象。
7. sizeof 运算不会计算静态成员变量的大小。
* 静态成员函数
静态成员函数是为某一个类服务的。静态成员函数不作用于某个具体的对象。普通成员函数隐含了一个 this 指针，该 this 指针指向类的对象本身。函数调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this 是缺省的。
静态成员函数属于类本身，不作用与具体的对象，因此它不具有 this 指针。静态成员函数不能访问非静态成员变量和非静态成员函数，只能访问其余的静态成员变量和函数。
* 静态成员函数的特点
1. 出现在类体外的函数定义不能指定关键字 static
2. 静态成员函数仅可以访问静态成员变量和静态成员函数
3. 静态成员函数不能访问非静态成员函数和非静态成员变量
4. 非静态成员函数可以任意的访问静态成员函数和静态成员变量
* 拷贝构造函数的问题
使用包含静态成员的类时，有时会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时类对象消亡时会调用析构函数，析构函数中可能会修改静态成员变量，但是这些临时对象在创建时却没有执行构造函数中的对静态成员变量修改的操作。此时应当在类中写一个拷贝构造函数，让临时对象的创建使用该拷贝构造函数，在拷贝构造函数中规范拷贝对象时的操作。
* 静态全局变量
在全局变量之前加上 static 关键字。
* 静态全局变量的特点
1. 该变量在全局数据区分配内存
2. 未经初始化的静态全局变量有一个默认的初始化值。与之相比，普通变量的默认初始化值是垃圾值。
3. 静态全局变量在声明它的整个文件内都是可见的，在文件外不可见。
4. 对于一个完整的程序，在内存中的分布情况如下：【代码区】、【全局数据区】、【堆区】和【栈区】。一般由 new 产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部数据）存放在全局变量区。
5. 静态全局变量不能被其他文件使用。在其他文件中，可以定义相同名字的变量，不会产生冲突。
* 静态局部变量
在局部变量之前加上 static 关键字，该变量就被定义为一个静态局部变量。
函数中的普通局部变量存放在栈中，函数退出时系统会回收栈的内存，局部变量也就失效了。
有时，我们希望在两次调用之间对局部变量的值进行保存，此时就可以使用静态局部变量。
静态局部变量只在第一次函数调用时初始化一次。且存放在全局数据区，每次调用的值保持到下一次调用。
静态局部变量始终驻留在函数的全局数据区中，直到程序运行结束。但其作用域为局部作用域，当定义它的语句块结束时，其作用域随之结束。
* 静态函数
在函数的返回类型前加上 static 关键字，函数被定义为静态函数。静态函数只在声明它的文件中可见，不能被其他文件使用。其他文件中可以定义同名函数，不会发生冲突。
## 虚函数与纯虚函数
### 多态
* 虚函数是实现多态的机制。多态性使得程序调用的函数是在运行时动态决定的，而不是编译时静态决定的。其核心理念是通过基类访问派生类实现的函数。使用一个基类类型的指针或引用指向子类对象，进而调用由子类复写的个性化的虚函数。
* 虚函数，在类的成员方法的声明前加 virtual 关键字。
```C++
virtual void f();
```
* 纯虚函数，在虚函数的声明后加 “= 0”
```C++ 
virtual void f() = 0;
```
* 虚函数表
每一个包含虚函数的类都包含一个虚函数表
虚表是一个指针数组，指针是指向虚函数的函数指针。
虚表是属于类的，而不是属于某个对象，一个类只需要一个虚表即可。同一个类的所有对象公用一个虚表。
为了指定对象的虚表，对象内部包含一个指向虚表的指针。类对象在创建时便拥有了指向虚表的指针，指针会自动指向对象所属类的虚表。
对象的虚表指针指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数。
* 对于虚函数，子类可以重写虚函数，也可以不重写。对于纯虚函数，子类必须重写。
* 当使用类指针调用成员函数时，普通函数由指针类型确定，虚函数由指针指向的实际类型确定。
* 含有纯虚函数的类成为抽象类，它不能生成对象。
* 当基类中的某个成员方法，在大多数情况下都应该由子类提供个性化实现，但基类中也可以提供缺省的备选方案时，该方法设计为虚函数。当基类的某个成员方法，必须由子类提供个性化实现时，应该设计为纯虚函数。
* 构造函数不能是虚函数，析构函数可以是虚函数且推荐设置为虚函数。基类的析构函数是虚函数，可以确保，在使用基类指针销毁派生类对象时，派生类的析构函数能够被调用，因为派生类的虚构函数一般会有释放一些派生类对象独有的内存这样的操作。
## 函数指针
函数存放在内存的代码区域，同样具有地址。
函数指针指向的函数一定要保持函数的返回值类型，函数参数个数、类型和函数指针一致。
函数指针可以作为参数传递给函数
还可以构成函数指针数组
类成员函数指针和普通函数指针是不同的。
类成员函数指针要通过 `.*` 或者 `->*` 运算符使用。
类成员函数指针指向类中的非静态成员函数时，必须由类的实例对象调用，用于传递给函数 this 指针。
指向类的静态成员函数的函数指针在声明时可以不加类名。调用时可以不使用类的实例对象。
普通成员的函数指针可以通过 `*` 运算符使用。
## 内联函数
内联函数是为了解决程序中函数调用的效率问题。如果函数为内联函数，则在程序编译时，编译器会将程序中出现的内联函数表达式用内联函数体进行替换。是一种空间换时间的操作。内联函数一般都比较小。
内联函数中最好不要使用循环语句，内联函数的定义必须出现在内联函数第一次调用之前，类内部定义的函数是内联函数。
## 函数签名
C++ 的函数签名包含函数名和函数的参数列表，不包含返回类型。函数签名用于识别不同的函数。
## 构造函数
构造函数不需要用户调用，而是在建立对象时自动执行。函数名称与类名相同，没有返回值。
1. 无参数的构造函数
2. 带参数的构造函数，属于构造函数的重载。构造函数的参数可以有默认初值。
## 拷贝构造函数
用于对象复制。函数名与类名一致，参数是一个本类型对象的引用。
* 拷贝构造函数调用时机
1. 对象以传值的方式传入函数参数时。
2. 对象以传值的方式从函数返回时。
3. 使用另一个同类型的对象来初始化新创建的对象时。
* 深拷贝与浅拷贝
默认的拷贝构造函数没有处理类的静态数据成员。
浅拷贝是指，在对象复制时，只对对象中的数据成员进行简单的赋值，也不会正确处理指针，指针只是简单的指向相同的内存空间。此时，拷贝出来的对象会影响原来的对象。
深拷贝时，对象中的成员变量，不再是简单的赋值，而是重新分配内存空间。
## 指针与引用的区别
* 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。引用跟原来的变量是同一东西，只不过是原变量的一个别名而已。
* 有 const 指针，没有 const 引用
* 指针可以有多级，引用只能由一级
* 指针可以为空，引用不能为空



# 编译器文法分析模拟器
* 简单介绍项目
项目是一个只有前端没有后端的静态化 Web 应用。项目通过可视化的方式，动态的展示了 LL(1) 文法的分析过程。项目主要是用来辅助老师教学。用户首先自定义一个上下文无关文法，然后通过消除文法中的左递归和提取左因子化简文法，简化的目的是尝试将用户自定义的上下文无关文法化简为 LL(1) 文法。计算化简后文法的 First 集合和 Follow 集合。通过 First 集合和 Follow 集合的信息判断当前文法是否属于 LL(1) 文法。如果是，则继续生成预测分析表，否则提醒用户去修改文法。
* 为何选用 Nuxt.js 作为开发框架？
因为项目是一个没有后端的静态化 Web 应用，Nuxt.js 可以把基于 Vue.js 的应用生成对应的静态站点，所以就选用了 Nuxt.js。
* 如何进行项目管理的？
使用华为云项目管理平台进行的项目管理。主要使用了平台的需求规划、迭代和测试管理这三个功能。代码使用 git-flow 进行版本控制。需求分析-用例归约描述-项目计划（项目开发计划和测试计划）-解决方案说明书-设计原型-编码-测试。小组成员每周开两次例会，写一次周报，借此来监控项目进度。
* 项目技术细节？
项目使用了 Element-UI 组件库中的一些基础组件，也自定义了很多组件，比如 “计算 First 集合” 的组件、“计算 Follow 集合” 的组件。
* 你做的工作？
实现四个功能。读取用户输入、检查并消除文法中的左递归（包括立即左递归和间接左递归）、计算文法的 First 集合并动态展示计算过程和判断文法是否属于 LL(1) 文法这四个功能。
    1. 读取用户输入
    就是读取用户自定义的文法符号和产生式，然后将其转换为我们自定义的一个 grammar 对象。
    2. 检查并消除文法中的左递归
        2.1 检查并消除文法中的立即左递归
        立即左递归很好检查与消除。
        2.2 检查并消除文法中的间接左递归
        间接左递归需要经过两步或两步以上的推导才能检测出来，有一些难度，这里使用了回溯法进行检测。
    3. 计算 First 集合并动态展示计算过程
    计算 First 集合有标准的算法，只要将其翻译为代码即可。这里的难点是动态展示计算过程。要求达到的效果是，用户点击下一步，界面上显示下一步的计算结果，以此帮助用户理解算法的运行过程。
    解决方法是使用了 JavaScript 中的 Generator 函数，算法每进行一步就通过 yield 表达式返回当前算法状态并展示在前端界面上，然后返回 yield 表达式停下的地方继续执行算法。
    4. 判断文法是否属于 LL(1) 文法
    这里没有难度。有两条规则用于判断文法是否属于 LL(1) 文法。如果一个文法同时满足这两条规则，则属于 LL(1) 文法，否则不属于。
* 项目整体架构？
项目使用了单例模式，有一个单例对象 grammar，代表用户输入的文法。没有通过编码技巧保证全局只有一个 grammar 对象，只是要求大家在写代码时不可调用 grammar 的构造方法。。

# 内存数据库模型
* 简单介绍
通过控制台读入 SQL 语句，对 SQL 进行解析，调用对应的方法。可以解析八种 SQL 语句。
```SQL
create database databasename
drop database databasename
insert into tablename(column1,column2) values (value1,value2)
delete from tablename where column=value
select column1 from tablename where column2=value
update tablename set column1=value1, column2=value2 where column3=value3
create table tablename
(
	colume1 type,
	column2 type,
	primary key(column1)
)
drop table tablename
```
* SQL 语句解析过程
    * 首先从控制台读取 SQL 语句，让后词法分析器提取 SQL 语句中的 token 并传递给语法分析器，语法分析器获取 token 并分析 SQL 的语义，按照语义调用数据引擎的接口，实现 SQL 语句的执行。
    * 词法分析通过一个 scan 函数，一个字符一个字符的读取 SQL 语句。然后将读到的每一个词素，组成词法单元 token。有一个 Lexer 类实现词法分析。
    * 语法分析首先要获得一个词法分析器对象。然后不断调用词法分析对象的 scan 方法获取词法单元。然后通过一个 stmt 函数分析获得词法单元。其实就是一堆 switch 和 case，用 case 匹配预先定义好的 token-name。比如 CREATE、TABLE、DROP 等。然后调用 DBs 对象实现的方法来模拟 SQL 语句的功能。
    * 没有生成语法树，语义分析和语法分析放在一起了。或者说没有语法分析，只有语义分析。语义分析实现了类型检查。
    * 到语义分析就结束了。该编译器的功能就是把 SQL ��句翻译为 C++ 函数调用。。
* 数据库模拟
    * 有一个 DBs 对象，该对象用来管理所有的数据库。它的属性是一个 vector 数组，数组里面的值是一个个 Database 对象。DBs 对象有所有的操作数据库的方法。SQL 语句分析结束后就是调用这里的方法来模拟执行 SQL 语句。
    * 一个 Database 对象表示一个数据库。它的属性值有一个 string 类型的数据库名，一个 int 类型的变量记录库中表的个数和一个 vector 数组存储数据库中的所有表。数组里面的值是一个个 Table 对象。还有一些操作表的方法。
    * 一个 Table 对象来表示一个数据库中的表。它的属性值有一个 string 类型的表名，两个 int 类型的变量分别记录表的行数和列数。两个 vector 数组，分别存储行和列。数组里面分别是 Column 对象和 Row 对象。还有一系列操作属性值的方法。
    * 一个 Column 对象，用来表示 Table 中的某一列。属性值有 bool 类型的主码标识，string 类型的列名，一个枚举类型的变量，表示列的数据类型，只做到了支持 varchar 类型。一个 bool 类型的变量，用于标识当前列是否允许为空。一个 int 类型的变量用于记录列值的长度。还有一些列操作属性的方法。
    * 一个 Row 对象，用于表示 Table 中的某一行。属性值只有一个 string 类型的数组，记录一行的内容。
    * 一个 Where 类，用于支持 where 语句，只有两个属性，一个 string 类型的列名，一个 string 类型的变量记录 where 语句中的值。
    * create database 方法实现
        * 创建一个数据库就是创建一个 Database 对象。。然后加入 DBs 对象的 vector 数组中。。
    * drop database 方法实现
        * 就是将 DBs 对象的 vector 数组中对应的 Database 对象删除。。
    * insert 方法实现
        * 通过 vector 的 push_back 方法实现的。。插入的时候先检查要插入行的主码是否与已经存在的行的主码相同。。
    * delete 方法实现
        * 通过 vector 的 erase 方法实现的。。
    * select 方法实现
        * 找到对应的数据库，找到对应的表，找到对应的行，然后将行显示出来。
    * update 方法实现
        * 找到对应的数据库，找到对应的表，找到对应的行，然后将要修改的内容修改了。
    * create table 方法实现
        * 先检查要创建的表是否存在，然后用 push_back 将新建的 Table 对象加入 Database 对象的记录 Table 的 vector 数组中。。
    * drop table 方法实现
        * 先检查要创建的表是否存在，然后使用 erase 方法将要删除的表删除。。
* 序列化
    * 使用了 boost 库。
    * 之前提到的每一个类都有一个对应的结构，用来序列化。该结构的属性和对应的类的属性相同，有一个用来序列化的函数。
    * 首先将对象转换为对应的结构。然后再序列化。
# Linux 文件系统
* 简单介绍
二级文件系统有一个根目录，每个用户在根目录下创建自己的用户目录，用户可以在自己的用户目录下创建文件。使用 C++ 的文件操作函数，对文件进行读、写、删、查操作。
* 文件系统结构
    * 使用一个真正的文件夹模拟磁盘。该文件称为 file system。
    * 规定该文件系统最大 100KB，一个 block 的大小为 1KB，单个文件最大 1KB，系统的 inode 个数为 100。
    * 使用一个名为 superblock 的整数数组记录 inode 和 block 的使用情况。下标 1~100 记录 inode 的使用情况，101~200 记录 block 的使用情况。程序退出时，将该数组写入 file system 目录下的一个名为 superblock.bin 的文件。相当与使用位图管理磁盘空闲块。
    * 使用一个名为 account 的 map<string,string> 记录用户的帐号和密码。程序退出时，写入file system 目录下的一个名为 users.bin 的文件。
    * 使用一个名为 inode 的 map<int,fileAttribute> 记录 inode 结点。fileAttribute 记录了文件的基本属性。程序退出时，写入file system 目录下的一个名为 inode.bin 的文件。
    * file system 文件夹下有一个 node 文件夹，里面存放 username.bin 文件，记录用户创建的文件名和文件对应的 inode number。相当于系统文件目录。程序启动时读入到一个名为 fileTable 的 map<string,int> 中。
    * file system 文件夹下有一个 userfiles 文件夹，里面存放用户创建的文件，使用 inode number 命名。
* 方法实现
    * signIn 用户注册
    就是简单的在 account 中添加一项。添加之前检查该用户是否已经存在。
    * logIn 用户登陆
    检查用户输入的帐号密码是否在 account 中。
    * createFile 创建文件
    找到一个空闲的 inode number，找到一个空闲的 block，然后在 userFiles 目录下创建文件，该文件以 inode number 命名。
    * deleteFile 删除文件
    在 fileTabe 中查找文件是否存在，找到了就删除，释放文件占用的 inode number 和 block。
    * openFile 打开文件
    在 fileTable 中查找文件是否存在，找到了就返回文件的 inode number。

# 字节跳动 一面
## 经验
* 复习知识点时要全面准确，一定要全面，因为面试官会根据你的回答向深处问！！
* 不会的要说不会。
* 算法要有一定的基础，LeetCode 的简单和中等难度的题要能解决。
* 对面试官的问题有疑惑就直接问清楚。
* 遇到不会的算法题，自己边想边说，面试官可能会给出一些指导。要会找话头。
## 内容
* 自我介绍 就是把自己的简历复述一遍 说的时候有些紧张。。
* 项目 编译器文法分析模拟器 
    * 直接跳到了编译器有哪几部分，是怎么实现的
    * 一个可执行的二进制文件从打开到执行的步骤是怎样的（不会）
* 项目 内存数据库模型
    * 解析 SQL 语句的编译器是怎样实现的
    * 数据库使用什么模拟的？STL 里面的 vector
    * 数据库事务的特征（不会，就答了一个原子性）
* 项目 二级文件系统
    * 基本功能
    * 进程打开的第一个文件时，对应的文件描述符是什么（3）
    * 文件描述符是什么
    * 系统打开文件表里面存放什么东西（不会）
* 说一下 TCP 协议的三次握手和四次挥手
* 在第四次挥手后为何要有 TIME_WAIT 状态
* 如果有两个线程，同时修改一个变量 i，使 i 的值增加一，i 的初始值为 0，不加锁，i 会有几个可能结果。为什么会有这样的结果，怎么解决？
* 信号量是怎么实现的？（硬件实现）怎么用硬件实现？实现在哪个硬件中？用什么硬件实现？
* C++ 语言细节
    * const 关键字的用途。（只答了修饰普通变量，指针，函数参数）
* 算法题：循环有序数组的二分查找、固定几个数字组成的下一个比当前数字大的数
* 有啥问题想问面试官，最近在读什么书？

# 字节跳动 二面
## 经验
* 刷算法题。见多识广，做的少了就会露馅。要写代码。
* 基础知识要牢固。
## 内容
* 自我介绍
* 基于简历上的项目提问
* 项目 编译器文法分析模拟器
    * 简述模拟器实现的功能
    * 如何实现一个正则表达式匹配引擎（词法分析）
* 项目 内存数据库系统
    * 解析 SQL 语句时，如何判断 where 语句中的关系的优先级（不会）
    * 数据库是如何存储在内存中的
* 项目 二级文件系统 结合操作系统提问
    * 虚拟内存 只有 4G 内存的机器上能运行 8G 大小的程序吗？
    * 虚拟内存的实现细节
    * 页面置换算法
* C++ 
    * map 容器实现方式->红黑树->红黑树的定义->除了红黑树还可以用什么数据结构实现->跳表->还有吗？->散列表->实现一个散列表应当注意的细节->要有一个好的散列函数，要能解决散列冲突->散列冲突的解决方法有哪些？-> 开哈希和闭哈希
* 算法
    * 给 2000 万的高考考生按照分数排序（基数排序）
    * 给定 m 个不重复的字符 [a, b, c, d]，以及一个长度为 n 的字符串 tbcacbdata。问能否在这个字符串中找到一个长度为 m 的连续子串，使得这个子串刚好由上面 m 个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3。
        * 该题为 leetcode 30.串联所有单词的子串。知识点为哈希表、滑动窗口、字符串。解题文章：[LeetCode 图解|30.串联所有单词的子串-五分钟学算法][link1]
* 有什么想问的吗？
下次就问自己没做出来的题。。

[link1]:https://mp.weixin.qq.com/s/OnpzUjnBaUw9Y-tzsralJA