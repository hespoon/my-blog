---
title: exam
date: 2021-01-13 17:22:46
tags: 可信考试
---
可能导致命令注入的符号
管道符（|），连接上个指令的标准输出，作为下个指令的标准输入
内联命令（;），连续指令符号
内联命令（&），单个 & 符号，且放在完整指令列的最后端，表示将该指令放入后台工作
重定向符（>），将命令输出写入到目标文件中
重定向符（<），将目标文件中的内容发送到命令当中
反引号（`），可在两个反引号之间构造命令内容并返回当前执行命令的结果
感叹号（!），事件提示符，可以引用历史命令
倒斜线（/），放在指令前，有消除别名的作用；放在特殊符号前，则改特殊符号的作用消失；放在指令的最末端，表示指令连接下一行
换行符（\n），用在一行命令的结束，用于分割不同的命令行
上述字符也可以通过组合的方式影响命令拼接，如管道符“||”，“>>”，“<<”，逻辑操作符“&&”。这些字符可以通过检测单个危险字符检测出。
表示用户 home 目录的“~”，表示上层目录的“..”，文件名通配符“?”，“*”由于只影响命令本身的语义，不会引入额外的命令，因此未列入命令注入涉及的特殊字符，需要根据业务本身的逻辑进行处理。

构建过程中文件路径的使用

函数搬移的定义

如何命名拆解出来的小函数

函数传参时，传值效率和传指针效率和传引用效率

std::tuple 的使用
tuple 是一个泛化的 pair，tuple 可以有任意数量的成员
当我们希望将一些数据组合为一个单一对象，但又不想新定义一个结构体时，可以使用 tuple。tuple 是一个快速且随意的数据结构。
可以通过 std::get<i>(t) 获取 tuple 中第 i 个成员的引用，i 从 0 到 tuple 元素个数减一
可以通过 std::get<type>(t) 获取 tuple 中类型为 type 的元素，必须要保证 tuple 中有且只有一个该类型的元素，否则会编译报错。


std::unique_ptr 的使用，release 后会发生什么变化，reset 函数的作用
unique_ptr 调用 release() 函数后会释放其指向的对象，并将自身置为 nullptr
reset() 函数会使 unique_ptr 释放并析构原来的对象，然后指向 reset 参数中的对象
get() 函数返回一个指向 unique_ptr 指向对象的指针，如果 unique_ptr 没有指向对象，则返回 nullptr
p.reset(p.release()) 的效果和 p.reset(p.get()) 是一样的

多继承中，出现了两个父类里面包含同名函数，如何指定调用某一个函数？
在 . 操作符后加上类名

函数栈帧会使用两个指针分别指向栈顶和栈底，分别为 ESP 和 EBP
函数的返回地址通过 call 指令入栈
X64 架构下，函数首先通过寄存器传参，然后再使用栈帧传参。函数的前四个参数使用 rcx，rdx，r8，r9 这四个寄存器传参，其他的的参数使用栈帧传递，从右向左入栈

gdb 以指定格式打印指定地址的内容
使用 examine 命令，缩写为 x，语法格式如下
x/ <n/f/u> <addr>
n 是一个整数，表示显示内存的长度，单位为字节
f 是格式化方式
u 指定一次显示多少字节的数据，默认是 4 字节，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节

DT FUZZ 测试，不适合使用 FUZZ 工具自动生成变异数据的类型

DevOps 是什么？


可以使用 sort 函数的容器
容器内的元素必须可以随机访问
元素必须支持 '<' 运算符
元素必须提供移动构造函数和移动赋值运算符
array，vector，deque 三个容器满足条件一

删除迭代器指向的元素后，迭代器的状态是什么？
迭代器失效

set 容器中的值是否可以修改？
不可以，set 容器中的元素是只读的

std::condition_variable 可以单独使用吗？
不可以，需要和互斥锁一起使用

C++ 中的格式化输入输出
C++ 为标准输入输出定义了一系列的格式化标志，这些标志可以通过 cout/cin 的成员函数 flags()、setf()、unsetf() 等函数操作
C++ 可以使用流操作算子控制输入输出的格式，也可以通过 cout/cin 的成员函数控制格式
http://c.biancheng.net/view/275.html

类的大小
与类大小有关的元素：非静态成员变量，虚函数，继承（单一继承，多重继承，重复继承，虚继承）
与类大小无关的元素：静态成员变量，成员函数
如果类有虚函数，或者父类中有虚函数，则会有一个 4 字节的指向虚函数表的指针
gcc 中，如果类虚继承了父类，则会有一个 4 字节的虚指针指向父类，如果父类也有虚函数，则子类和父类公用一个虚函数指针，该指针的大小不计算到子类的大小中，如果父类没有虚函数，子类有虚函数，则子类还是只有一个虚指针，不会有两个。
如果类继承了两个父类，且两个父类中都有虚函数，则该类会有两个指向虚表的指针
类中的非静态成员变量的大小会计算到类的大小中，静态成员变量和函数不计入类的大小中
空的类的大小为 1，因为空类可以实例化，所以编译器将其优化为 1 字节的大小。空类被继承后，子类的大小会忽略父类那个 1 字节的大小
计算大小时要考虑字节对齐
子类中重写父类虚函数的函数，即使没有加 virtual 关键字，该函数也是虚函数

类的封装
public 关键字修饰的成员，可以被所有人访问，包括类内部，类的派生类，类的实例，派生类的实例
protected 关键字修饰的成员，可以被类内部和派生类内部访问，不可以被类的实例和派生类的实例访问
private 关键字修饰的成员，只可以被类内部访问，不可以被派生类，派生类的实例和类的实例访问

类的继承
public 继承基类
基类中的 public 成员在派生类中为 public
基类中的 protected 成员在派生类中为 protected
基类中的 private 成员在派生类中不可访问
protected 继承基类
基类中的 public 成员在派生类中为 protected
基类中的 protected 成员在派生类中为 protected
基类中的 private 成员在派生类中不可访问
private 继承基类
基类中的 public 成员和 protected 成员在派生类中为 private
基类中的 private 成员在派生类中不可访问
总之，基类成员在派生类中的访问权限不得高于继承方式中指定的权限；不管如何继承，基类中 private 成员都不能在派生类中访问
虽然基类的 private 成员不能访问，但是可以被继承，也就是会占用派生类的内存

父类指针指向子类对象，析构
delete 父类指针时，如果父类的析构函数不是虚函数，则只会调用父类的虚构函数

引用和指针才会有多态
函数是非虚函数时，调用指针对应类型的函数；函数是虚函数时，调用指针指向的对象的类型的函数
如果在构造函数中调用虚函数，不会有多态的效果，只会调用本身声明的那个函数，如果该函数在该类中没有定义，则会链接出错
虚函数可以实现静态绑定，但是虚函数的默认参数是静态绑定的。
当虚函数有默认参数时，默认参数的值由指针类型决定，但是调用的函数还是按照多态规则，由指针指向的对象决定。
函数重写，要求父类虚函数和子类重写虚函数的函数要和父类中的虚函数一模一样，包括参数列表和函数体之间的修饰符也要相同，否则是重载，不是重写。

函数重载后的参数精确匹配
编译器将实参类型到形参类型的转换划分为 5 等，越靠前匹配度越好
	1. 精确匹配。包括实参类型和形参类型，实参从数组或函数转换为对应的指针类型，向实参添加顶级 const 或从实参删除顶级 const
	2. 通过 const 转换实现的匹配
	3. 通过类型提升实现的匹配
	4. 通过算数类型转换实现的匹配
	5. 通过类间的类型转换实现的匹配。比如从子类转换为父类

带有小数点的数字默认是 double 类型的
析构函数只能有一个，并且不能有参数

继承构造函数
子类为完成基类的初始化，在 C++11 之前，需要在子类的初始化列表中显示调用基类的构造函数，从而完成构造函数的传递。如果基类有多个构造函数，则子类就需要实现多个与基类构造函数对应的构造函数。在子类中实现多个构造函数只为传递参数完成基类的初始化，这种方式无疑很麻烦。
子类构造时会显示调用父类的构造函数没错，但是调用的是父类的默认构造函数。如果在子类构造函数的初始化列表中显示调用了父类的有参构造函数，就不会再调用父类的无参构造函数了。
通过继承父类的构造函数，可以避免子类实现多个构造函数但是只为传递参数的情况。
如果子类也需要在构造函数中初始化自己的成员，则需要显示定义一个构造函数，并在初始化列表中调用父类的构造函数，否则会调用父类的默认构造参数。构造函数执行时，先执行初始化列表中的代码，再执行函数体。执行构造函数的函数体时，类成员的初始化已经结束了。
如果子类继承了多个父类，继承构造函数可能会出现冲突的情况。因为多个基类中的部分构造函数继承到子类中后，可能会因为签名相同而产生冲突。
继承构造函数是隐式生成的，也就是说不用的话是不会产生代码的。
继承构造函数时，不会继承父类构造函数中的参数的默认值，并且会在子类中生成多个版本的构造函数。
https://blog.csdn.net/K346K346/article/details/81703914

全局类对象的构造函数在 main 函数之前执行
子类中重写父类虚函数的函数，依旧是虚函数，依旧可以被继承该子类的函数重写
类的成员可以有两种初始化方式，一种是通过构造函数的初始化列表初始化，一种是通过 = 或者 {} 在该成员声明时就初始化。
并且，构造函数的初始化列表初始化比声明时初始化优先级要高。对于一个成员，如果在初始化列表中初始化了，则声明时初始化的代码不再起作用。

成员的初始化顺序
成员的初始化顺序与它们在类定义中出现的顺序一致：第一个成员先被初始化，然后第二个，以此类推。
构造函数初始化列表中初始值的前后位置关系不会影响实际的初始化顺序。
当一个成员使用另一个成员初始化时，成员的初始化顺序就要额外注意。
最好令构造函数初始化列表的初始化顺序和成员的声明顺序一致，并且，尽量避免使用某些成员初始化其他成员。

虚继承中的成员初始化顺序
虚基类是由最底层的派生类初始化的
首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。
虚基类总是先于非虚基类构造，这与它们在继承体系中的次序和位置无关

如果有一个构造函数给每一个参数都提供了默认值，则该构造函数会被当作默认构造函数。
有纯虚函数的类是抽象类，抽象类是不能被实例化的。
继承抽象类的类如果不是抽象类，则必须实现父类中的纯虚函数，如果该类依旧是抽象类，则可以不实现父类的纯虚函数。如果该类没有实现纯虚函数，则该类默认为抽象类。

虚函数返回值的协变
子类实现父类的虚函数时，子类中函数的函数名，参数列表和返回值必须与父类中的虚函数一致。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果 D 由 B 派生得到，则基类中的虚函数可以返回 B* 而派生类对应的函数可以返回 D*，这样的返回类型要求从 D 到 B 的类型转换是可访问的。

回避虚函数的机制
当不希望对虚函数调用执行动态绑定，而是强迫执行某个版本的虚函数，可以使用作用域运算符实现该目的。
baseP->Quote::net_price();
该代码强行调用 Quote 的 net_price 函数，而不管 baseP 实际指向的对象类型到底是什么，该调用将在编译时完成解析。
这通常使用在成员函数中调用虚函数或者友元函数调用虚函数中，或者派生类的虚函数中需要调用基类的虚函数。
如果在派生类的虚函数中调用基类中的虚函数，而没有使用作用域运算符，则会导致派生类的虚函数调用自己，产生无限递归。

纯虚函数可以不用定义，但实际上可以提供纯虚函数的定义，但该定义必须写在类外面。
虽然抽象类的析构函数可以是纯虚函数，但是要实例化其派生类对象，必须提供抽象基类中析构函数的函数体。
在构造函数和析构函数中调用虚函数，都是静态联编的，不能实现动态联编。
构造函数负责初始化虚函数表指针的值，因此在构造函数中调用虚函数是没有用的
对象在析构时，先析构子类再析构父类，因此是无法调用到子类的虚函数实现动态联编的
抽象类被继承后，纯虚函数在子类中不再是纯虚函数，而是虚函数，除非子类不实现该纯虚函数，则该函数依旧是纯虚函数，子类是抽象类。
可以在构造函数中抛出异常，但禁止在析构函数中抛出异常。

C++ 异常 catch 子句的匹配规则
在搜寻 catch 语句的过程中，最终找到的 catch 未必是异常的最佳匹配，而是第一个与异常匹配的 catch 语句。因此，越是专门的 catch 越应该置于整个 catch 列表的最前端。
如果 catch 的参数是基类类型，则可以使用其派生类的异常对象对其初始化。
异常声明的静态类型将决定 catch 语句能执行的操作。如果 catch 的参数是基类类型，则 catch 无法使用派生类特有的任何成员。
catch 参数的匹配规则限制比较多，一般情况是要求异常的类型和 catch 参数的类型是精确匹配的。只有下面几个转换时允许的
	1. 允许从非常量向常量类型转换
	2. 允许从派生类向基类的类型转换
	3. 数组被转换为指向数组的指针，函数被转换为指向函数的指针
除此之外，所有的类型转换都不允许
如果在多个 catch 语句的类型之间存在着继承关系，则应当把继承链最低端的类（最后面的派生类）放在前面，继承链最顶端的类（最基类的基类）放在后面。
单条 throw 语句会抛出所有异常；throw e 语句只会抛出异常 e
typedef 语句中不能有异常规格声明

传值，传引用和传指针的效率
	1. 传递效率
	这里的传递效率，是指调用函数的代码将函数参数传递到函数体内的过程
	对于内建的 int、short、long、float、char 类型而言，参数传递时实际上传递的是 1-4 个字节。作为指针传递时，32 的 cpu 中传递的是 4 字节，此时传值和传指针的传递效率是一样的。对于 long long、double 等 8 字节的数据，在 32 位的 CPU 上传值的效率要低于传指针，而在 64 位的 CPU 上，传值和传指针的效率是相同的。
	对于传引用来说，不同编译器的效率不同，有的编译器使用指针实现引用，此时传引用的效率和传指针是一样的。有的编译器会做优化，传引用会使用直接寻址的方式访问变量，此时，传引用的效率是最高的。
	2. 执行效率
	这里的执行效率是指函数参数在函数体内被访问时的效率，访问起来越快，执行效率越高。
	传值调用时，由于参数会生成临时对象，因此所有对参数的访问都是直接寻址，效率较高。传引用和传指针在大多数情况下都是间接寻址，效率较低。
综上所述，传引用的效率总体上是不低于传指针的。

命名空间作用域结束后无需分号。
命名空间可以是不连续的。
内联的命名空间中的名字可以直接被外层命名空间使用，无需添加内联命名空间的名字。
只有在第一次声明内联命名空间时需要在 namespace 关键字前添加 inline，之后在该命名空间中添加名字时，不用 inline 关键字，该空间是隐式内联的。
inline namespace hbt{
	// 首次声明内联的命名空间
}

namespace hbt{
	// 后续使用时，该命名空间是隐式内联的
}

使用匿名 namespace 代替 static 关键字声明文件作用域的变量或函数。

using 声明，一条 using 声明语句只引入命名空间的一个成员。using A::I;
using 声明语句可以出现在全局作用域，局部作用域，命名空间作用域和类作用域中。在类作用域中，这样的声明语句只能指向基类成员。（比如继承构造函数）
using 指示，using指示语句引入一个命名空间中的所有名字。using namespace std;
using指示可以出现在全局作用域，局部作用域和命名空间作用域中，但是不能出现在类作用域中。

using 声明产生的命名冲突在声明时就能被静态检查出来。
using 指示产生的命名冲突只有在真正使用冲突的名字的时候才能发现。

::a 一般表示使用全局作用域中的名字 a

类的静态成员的访问方式：类名::成员名；对象名.成员名；对象指针->成员名;
类的静态成员一般在实现类的 .cpp 文件中初始化，表达式为：变量类型 类名::变量名 = 变量值;

类的静态成员函数只能直接访问类的静态成员和静态成员函数，可以通过类对象间接访问类对象的非静态成员。
类的静态成员函数是没有指向类对象的 this 指针的。

在头文件中如果有变量或函数的定义，而非声明，容易导致编译或连接时发生错误。
extern int j; // 声明变量 j 而非定义变量 j
int j；// 声明并定义变量 j
extern int j = 10; // 声明并定义变量 j
extern 语句如果包含了初始值就不再是声明，而是定义了。
变量可以声明多次，但只能定义一次。
不允许在函数体内初始化一个由 extern 标记的变量。
头文件中使用 extern 声明的变量是全局变量。并且应该只在一个 .cpp 文件中定义。

C++ 对头文件名没有后缀要求，标准 C++ 头文件名不带后缀。对于 C 的标准头文件，C++ 提供文件名前加 ‘c’，后面没有后缀的相应头文件。
C++ 代码中可以以 C++ 文件名格式包含原来 C 的标准头文件，也可以使用 C 的文件名格式包含原来 C 的标准头文件，但是不存在去掉后缀的标准 C 头文件。

#include 机制用于将源程序片段收集在一起，形成一个完成的编译单元作为编译器的输入。

C++ 对 extern "C" 定义的变量名不添加特殊标识，这样可以兼容老的 C 编译器编译的 OBJ 文件。
C++ 使用链接指示指出任意非 C++ 函数所用的语言。要想把 C++ 代码和其他语言代码编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前 C++ 编译器是兼容的。
链接指示可以是单个的也可以是复合的。链接指示不能出现在类定义或函数定义的内部。链接指示必须在函数的每个声明中都出现。

const 定义的常量必须在定义时初始化，可以用各种表达式初始化该常量，包括一个变量。

函数类型
函数类型由函数返回值和形参列表决定。
声明一个函数指针形式如下：bool (*pf) (string,int)
pf 两边的小括号不可少，* 也不能少
当把函数名当作一个值使用时，该函数名自动转换为函数指针
使用函数指针调用函数时，无需提前解引用
指向不同函数类型的指针间不存在转换规则。
可以使函数指针指向 nullptr 或 0，表示该指针没有指向任何函数。
函数指针声明时一般很长，可以使用类型别名和 decltype 简化使用函数指针的代码。
typedef bool (*pf) (string,int); // pf 是一个指向 bool(string,int) 类型函数的指针类型
typedef decltype(fun) *pf; // pf 是一个指向 fun 类型函数的指针类型
using pf = decltype(fun)*; // pf 是一个指向 fun 类型函数的指针类型
当使用 decltype 作用于函数时，返回的是函数类型，而非函数指针类型，因此需要显示加上 *
函数的返回类型不能是一个函数类型，但可以是一个函数指针类型。

*(p++) 是先取 p 指向的值，然后令 p 加一
*(++p) 是先令 p 加一，然后取 p 指向的值

可以使用字符串字面量初始化字符串数组，char s[10] = "hello";
不可以用字符串字面量初始化字符串数组的名子，char s[10]; s = "hello"; // 不可以，编译器报错，"hello" 被视为 const char[6]，不能赋值给 char[10]
引用不是对象，没有实际地址，所以不能定义指向引用的指针

NULL 是一个 long 类型的值，它既可以转换为 int，也可以转换为 void*，两种转换在寻找匹配的重载函数时被视为同一水平的转换。因此下面的代码会有二义性。
void Fun(int a) { cout << "Int\n"; }
void Fun(void *a) { cout << "Ptr\n"; }
Fun(NULL); // 代码有二义性，此时有两个匹配的函数。
g++ 编译器下，可以通过声明一个接受 long 型参数的函数来消除二义性
void Fun(int a) { cout << "Int\n"; }
void Fun(void *a) { cout << "Ptr\n"; }
void Fun(long a) { cout << "Long\n"; }
Fun(NULL); // 此时调用 void(long) 类型的函数，但是编译器会告警
g++ 编译器下，0 可以转换为 void*
void Fun(void *a) { cout << "Ptr\n"; }
Fun(0); // 可以调用 void(void*) 类型的函数
g++ 编译器下，nullptr 只能匹配指针类型，不能转换为 int 和 long 类型

C++ 允许 delete 空指针，此时 delete 啥都不做，相当于空操作

类的内存管理成员函数
类的内存管理的成员函数隐含是静态的，重载时是否写 static 都是正确的，因为 operator new 作用在对象创建之前，operator delete 作用在对象销毁之后，因此必须是静态的，并且不能操作任何类的数据成员。
operator new 或者 operator new[] 函数的返回类型必须是 void*，第一个参数的类型是 size_t 并且不能有默认实参。
调用 operator new[] 时，第一个参数传入的是整个数组占用的空间的大小。
void *operator new(size_t, void*); 这个函数不允许重载
operator delete 和析构函数相似，都不允许抛出异常，当重载 operator delete 函数时，必须使用 noexcept 指定该函数不会抛出异常。
对于 operator delete 和 operator delete[] 函数来说，返回类型必须是 void，第一个形参的类型必须是 void*。
当 operator delete 和 operator delete[] 定义为类的成员函数时，该函数可以包含另一个类型为 size_t 的形参。该形参的初始值是第一个形参指向的对象占用的字节数。
operator delete 和 operator new 是对函数的重载，无法改变 new 和 delete 表达式的含义。
new 表达式首先调用 operator new 函数获取内存空间，然后在得到的内存空间中构造函数。
delete 表达式总是首先销毁对象，然后调用 operator delete 函数销毁内存空间。
对于调用 operator new 获取的内存空间来说，我们无法使用构造函数在这块内存中构造对象。我们可以使用定位 new 在指定的内存上构造对象。
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] { braced initializer list }
调用析构函数可以销毁对象，但是不会释放对象占用的内存。 

switch(a) 语句会对表达式 a 求值，然后将改值转换为整数类型，然后与 case 标签比较。
使用乘法代替除法，可以提高浮点运算的效率

set 容器中的元素是只读的，不可以修改。
std::recrusive_mutex 和 std::mutex 是不等价的。std::recrusive_mutex 允许同一个线程对互斥量多次上锁。

函数调用运算符
如果类定义了函数调用运算符，则可以像使用函数一样使用该类的对象。
函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数或类型上有所区别
如果类定义了函数调用运算符，则该类的对象被称为函数对象。
函数对象常常作为泛型算法的实参。
函数对象可以使用自己的成员保存状态，因此函数对象比普通函数更加灵活。
lambda 表达式会被编译器翻译为一个未命名类的未命名对象，该类只有一个函数调用运算符成员。因此，lambda 表达式被当做函数对象处理。
函数对象，可以实现函数调用的内联，因此可以加快速度，提高程序性能。

可调用对象与 function
C++ 中的可调用对象有函数，函数指针，函数对象，lambda 表达式，bind 创建的对象。
不同类型的可调用对象可能会共享同一种调用形式。
调用形式指明了调用返回的类型以及传递给调用的实参类型，如 int(int,int)，接受两个 int，返回一个 int
一种调用形式对应一个函数类型。
当几个可调用对象共享同一个调用形式时，我们会希望将它们看为具有相同的类型。
标准库中的 function 类型，可以用来存储同一调用形式的不同类型的可调用对象。
function 类型是模板类型，该类型的对象在声明时需要在尖括号中指明调用类型。
function<int(int,int)> f; // 声明并定义了一个可调用对象，该对象接收两个 int，返回一个 int

虚表的实现
有虚函数的类，每个类都有自己的虚表指针和虚函数表。
虚表中存储的是指向虚函数的函数指针
假如父类有虚函数，子类继承父类，则父类的虚表指针指向父类的虚表，子类的虚表指针指向子类的虚表。
如果子类重写了父类的虚函数，则子类的虚函数表中的函数指针会指向子类实现的虚函数。
如果子类没有重写父类的虚函数，则子类的虚函数表中的函数指针会指向父类实现的虚函数。
编译器会保证虚表指针位于对象实例中的最前面，以保证虚函数访问的效率。

gdb 函数参数赋值

满足公司构建规范的脚本语言

安全编译 TMG 备案

开源义务
BSD 类，推荐使用 商业友好；Apache V2.0，BSD MIT
	1. 允许各种链接，无开源义务
	2. 允许修改，无开源义务
	3. 软件所有人授予专利许可
MPL 类，可以使用 需关注修改后的开源义务；CPL V1.0，EPL V1.0，MPL V1.0，CDDL V1.0
	1. 允许各种链接，无开源义务
	2. 允许修改，但部分修改需要开源
	3. 无专利规定
GPL 类，慎重使用
	1. LGPL V2 只允许动态链接方式使用
	2. GPL V2 由于导致产品整体负有开源义务，不建议使用
常见代码隔离方式
	1. 配置管理隔离，开源软件与自研代码分别单独目录存放，单个开源软件单独目录存放
	2. 代码应用隔离
	LGPL 类开源软件应采用动态链接方式使用
	GPL 类开源软件应采用进程隔离方式使用，产品与 GPL 软件位于不同进程，通过进程间通信进行交互；如果不能直接进程隔离，需要制作隔离层，隔离层开源，产品与隔离层之间进行进程间通信。如果产品只是对 Linux Kernel 运行一般系统调用，产品代码不会被 GPL 传染。
	应尽量以插件的形式应用开源软件，尤其是 GPL 和 LGPL 类软件，尽量减小产品代码与开源软件之间的依赖性，双方可独立完成编译且运行。

explicit 关键字
explicit 关键字不能用来限制类的普通成员函数，explicit 只能用来修饰构造函数和类型转换运算符。
如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，这种构造函数被称为转换构造函数。该函数定义了一种从构造函数的参数类型到类类型的隐式转换规则。也就是说，构造函数的参数类型可以替代该类类型。
编译器只会自动执行一步类型转换。字面量字符串和 string 是两种不同的类型。
explicit 关键字用于抑制这种隐式的类型转换。explicit 只对只有一个实参的构造函数起作用，有多个实参的构造函数也可以用 explicit 修饰，但是有没有 explicit 都一样，因为有多个函数的构造函数不能用于执行隐式转换。
只能在类内部声明构造函数时使用 explicit 关键字，在类外部定义时不应该重复。
explicit 构造函数只能用于直接初始化。
Drive b(10); // 直接初始化
Drive a = 10; // 使用了 int 向 Drive 类类型的隐式转换
虽然不能使用隐式类型转化，但是可以使用强制类型转换调用 explicit 构造函数。
Drive a = static_cast<Drive>(10); // 使用了强制类型转换
当子类继承父类的构造函数时，explicit 会同时被继承。

构造函数不能是 const 的，但是可以是 constexpr 的。

在每个 shell 脚本文件的第一行声明脚本解释器

std::make_unique，std::make_shared
make_shared 函数会申请一块内存并在该内存上构造对象。可能会抛出 std::bad_alloc 异常。
shared_ptr 会记录当前有多少其他的 shared_ptr 指向了它指向的对象。
将指针指向其他内存时，原内存的引用计数减一，当将指针赋值给其他 shared_ptr 时，原内存的引用计数加一，当一块内存的引用计数为 0 时，编译器会自动释放 shared_ptr 占用的内存。
shared_ptr 的析构函数在销毁 shared_ptr 对象时会将原内存的引用计数减一，当析构函数发现原内存的引用计数为 0 时，会自动销毁内存上的对象并释放该内存。
shared_ptr 的单参构造函数都是 explicit 的，因此不存在从内置指针向 shared_ptr 的隐式转换，shared_ptr 必须被显示构造。
make_unique 函数会申请一块内存并在该内存上构造对象。可能会抛出 std::bad_alloc 异常。

IPD 中要求使用 gcc 编译器必须开启的选项

构建加速的手段

测试，逻辑覆盖，条件覆盖，条件组合覆盖，语句覆盖，判定覆盖，路径覆盖

代码重构

故障管理的内容

memcpy_s 函数
errno_t memcpy_s( void *restrict dest, rsize_t destsz, const void *restrict src, rsize_t count );
函数执行成功返回 0，执行失败返回非零值
dest 指向目标缓冲区，destsz 是目标缓冲区的大小，src 指向源缓冲区，count 是要从源缓冲区读入目标缓冲区的字节数

sprintf_s 函数
int sprintf_s(char *restrict buffer, rsize_t bufsz, const char *restrict format, ...);
第三个参数是格式化字符串，返回值为成功写入目的缓冲区的字符个数

fgets 函数
char * fgets ( char * str, int num, FILE * stream );
str 指向存放字符串的缓冲区，num 是向缓冲区中读入字符的最大个数，包括 \0 字符
读到换行符终止，并且会存储读到的换行符；读到 eof 终止；读入了 num-1 个字符后终止
如果函数操作成功，返回值为 str；如果直接读到了 EOF，返回 nullptr，并且 str 中原来的内容不会改变；如果发生了 ferror，返回 nullptr 并且会改变 str 中的内容。

常见不可重入函数
rand, srand, getenv, getenv_s, strtok, strerror, asctime, ctime, localtime, gmtime, setlocale, atomic_init, tmpnam, mbrtoc16, c16rtomb,
mbrtoc32, c32rtomb, gethostbyaddr, getostbyname, inet_ntoa

声明数组引用
类型名 (&数组名) [数组长度]

禁止使用 kill、TerminateProcess 终止其他进程，杀死其他进程会导致资源不会释放。如果通知其他进程退出后，过了规定时间对方还未退出，可以用 kill 和 TerminateProcess
禁止在线程内使用 pthread_exit、ExitThread 主动终止自身线程
除了 main 函数，禁止其他任何地方调用 exit 和 ExitProcess 函数退出进程
禁止使用 abort 函数，只有在发生致命错误，程序无法继续执行时，在错误处理函数中执行 abort

10 进制 int 数的最大存储长度是 12 字节

系统的绝对路径一般由 PATH_MAX 常量定义或者由 _PC_PATH_MAX 系统值配置的，通常大于 100 字节

对字符串进行存储操作，必须保证字符串结尾有 \0 结束符，否则在后续的 strlen 等操作中，可能会导致内存越界访问

外部数据作为数组索引时，必须确保索引在数组大小范围内

禁止格式化函数的 format 参数外部可控
xxxprintf, xxxscanf, err, verr, errx, verrx, warn, vwarn, warnx, vwarnx, error, error_at_line, syslog, vsyslog
不允许：
char *msg = GetMsg();
printf(msg);
推荐：
char *msg = GetMsg();
printf("%s\n", msg);

格式化函数中参数类型与个数与实际参数不一致，会导致读写的数据与期望不一致，造成输入输出数据错误，访问非法内存，写越界等问题。
例外的是，signed char，signed short 可以使用有符号整形格式 %d 输出，unsigned char，unsigned short 类型参数可以使用无符号整形格式 %u 输出

必须检查安全函数的返回值，如果返回值不等于 EOK，则本函数一般情况下应该立即返回，不能继续执行。
如果在安全函数返回值检查错误处理的代码中又调用了安全函数，则可以不进行返回值检查
整形表达式比较或者赋值为一种更大类型之前，必须使用这种更大类型对它进行求值。
禁止对有符号整数进行位操作运算符运算。（~, >>, <<, &, ^, |）但是对于视频，音频，图像等数学运算操作，可以例外
指针的大小随着平台的不同而不同
禁止对指针进行逻辑或位运算（&&, ||, !, ~, >>, <<, &, ^, |），就是禁止把指针放在 if 语句中判断
下面的操作是禁止的：
const char *a;
if(a){
    ...
}
推荐这样做：
const char *a;
if (a != nullprt) {
  ...
}
为检查地址对齐而对地址指针进行的位运算可以作为例外
不能申请长度为 0 的内存
malloc 和 new 不会初始化申请到的内存
禁止使用 realloc 函数
禁止使用 alloca 函数在栈上申请内存
禁止外部数据作为进程启动函数的参数：system, popen, WinExec, ShellExecute, execl, execlp, execle, execv, execvp, CreateProcess
禁止外部可控数据作为模块加载函数的参数：dlopen, LoadLibrary
对于使用了密钥，签名机制保护的动态模块，由于其完整性有充分保证，可以例外
禁止在信号处理例程中调用非异步安全函数。
禁止使用 setjump 和 longjump
禁止使用内存操作类危险函数
对于未涉及到外部数据处理，不存在被攻击场景，内存操作完全在本函数内完成，不存在因外部控制而失败的可能性时，可以使用危险函数。
	1. 对固定长度的内存进行初始化，或对固定长度的结构体进行内存初始化
	2. 函数参数中有表示内存的参数，对该内存进行初始化
	3. 从堆中分配内存后，赋予初始值
	4. 根据源内存的大小进行同等大小的内存复制
	5. 源内存全部是静态字符串常量
	6. 使用 Visual Studio 2005 及更高版本开发 windows 程序时，使用了微软提供的安全函数，
	7. 对于一次拷贝可能超过 2G 连续字节的内存操作，在确保源和目的缓冲区长度大小相同且各参数均正确有效的情况下，可以使用危险函数

创建文件时，必须显示指定合适的文件访问权限
禁止：
int fd = open(fileName, O_CREAT | O_WRONLY); // 未指定文件访问权限
推荐：
int fd = open(fileName, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);

必须对文件路径进行规范化。
linux 使用 realpath 函数，windows 使用 PathCanonicalize 函数
规范化后，在判断路径是否是本程序所认为的合法路径
对于控制台的命令行程序，通过控制台手工输入文件路径，可以作为例外，不用规范化，直接使用
存储在内存中的敏感信息要及时清零，同时防止因编译器优化而使清理代码无效。
禁止使用 string 类存储敏感信息，应当使用 char 或 unsigned char 保存敏感信息。

传参时数组长度是否要同时传递
原则：数组作为函数参数时，必须同时将其长度作为函数的参数
数组是固定长度的数组时，也必须将数组大小作为函数的参数
如果参数是 char*，且参数作为写内存的缓冲区，那么必须传入其缓冲区长度。
例外：const char* 类型的参数，它的长度是通过 '\0' 的位置计算出来的，不需要传递长度
例外：如果函数仅对字符串中的特定字符进行一对一替换，或者删除字符串中特定字符，这时对字符数组的访问不会超过原字符串边界，因此这类函数不需要传待修改的字符串的长度。
例外：对于 const struct* 类型的数组入参，如果它的长度可以通过特定元素值判断结尾，那么可以不传递结构体数组长度
例外：对于固定长度的数组，如果使用数组的头地址作为函数参数，由于性能原因，可以不用传递其长度。
例外：C++ 编译器会检查固定长度数组名的引用，如果函数参数不符合引用的数字定义的类型和长度，编译器可以检查出来并报错。因此，C++ 中引用固定数组名的参数，不必再额外传递长度参数。

可能使迭代器失效的容器操作
向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。失效的指针、引用或迭代器不再代表任何元素。使用失效的迭代器可能会引起与使用未初始化指针一样的问题。
	1. 向容器中添加元素后
	• 对于 vector 和 string，如果存储空间发生了重新分配，则指向容器的迭代器、指针和引用都会失效。如果未发生存储空间的重新分配，则指向插入位置之前的元素的迭代器、指针和引用仍然有效，但插入位置之后元素的迭代器、指针和引用都会失效。
	• 对于 deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾添加元素，则迭代器会失效，但指向存在的元素的引用和指针不会失效
	• 对于 list 和 forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用依然有效。
	2. 从容器中删除元素后
	• 指向被删除元素的迭代器、指针和引用会失效，因为元素已经删除了
	• 对于 list 和 forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器），引用和指针仍然有效。
	• 对于 deque，在首尾之外的任何位置删除元素，则指向被删除元素外其他元素的迭代器、引用和指针都会失效；如果删除尾元素，则尾后迭代器失效，但其他迭代器、指针和引用不受影响；如果是删除首元素，首前迭代器，尾后迭代器失效，其他迭代器、指针和引用不受影响
	• 对于 vector 和 string，指向被删除元素之前元素的迭代器、引用和指针仍然有效，之后的迭代器、引用和指针失效。
当删除元素时，尾后迭代器总会失效。尾后迭代器就是 end 函数返回的迭代器。
insert 函数返回指向当前元素的迭代器，erase 函数返回指向下一个有效元素的迭代器

安全函数中的 destMax 参数必须设置正确，设置时不能用魔鬼数字。
